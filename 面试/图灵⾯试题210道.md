> 道⾯试题
>
> Java基础()
>
> ⾯向对象
>
> JDK、JRE、JVM之间的区别
>
> ==和equals⽅法之前的区别
>
> hashCode()与equals()之间的关系
>
> final关键字的作⽤是什么？
>
> String、StringBuffer、StringBuilder的区别
>
> 重载和重写的区别
>
> 接⼝和抽象类的区别
>
> List和Set的区别
>
> ArrayList和LinkedList区别
>
> HashMap和HashTable有什么区别？其底层实现是什么？ 谈谈ConcurrentHashMap的扩容机制
>
> Jdk.到Jdk. HashMap 发⽣了什么变化(底层)? 说⼀下HashMap的Put⽅法
>
> 泛型中extends和super的区别
>
> 深拷⻉和浅拷⻉
>
> HashMap的扩容机制原理
>
> CopyOnWriteArrayList的底层原理是怎样的
>
> 什么是字节码？采⽤字节码的好处是什么？
>
> Java中的异常体系是怎样的
>
> Java中有哪些类加载器
>
> 说说类加载器双亲委派模型
>
> GC如何判断对象可以被回收
>
> JVM中哪些是线程共享区
>
> 你们项⽬如何排查JVM问题
>
> ⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？ 怎么确定⼀个对象到底是不是垃圾？

1

> JVM有哪些垃圾回收算法？
>
> 什么是STW？
>
> JVM有哪些垃圾回收器？
>
> 垃圾回收分为哪些阶段
>
> 什么是三⾊标记？
>
> JVM参数有哪些？
>
> Java并发()
>
> 线程的⽣命周期？线程有⼏种状态
>
> sleep()、wait()、join()、yield()之间的的区别
>
> 对线程安全的理解
>
> Thread和Runable的区别
>
> 对守护线程的理解
>
> ThreadLocal的底层原理
>
> 并发、并⾏、串⾏之间的区别
>
> 并发的三⼤特性
>
> Java死锁如何避免？
>
> 如何理解volatile关键字
>
> 为什么⽤线程池？解释下线程池参数？
>
> 线程池的底层⼯作原理
>
> 线程池中阻塞队列的作⽤？为什么是先添加列队⽽不是先创建最⼤线程？ 线程池中线程复⽤原理
>
> ReentrantLock中的公平锁和⾮公平锁的底层实现
>
> ReentrantLock中tryLock()和lock()⽅法的区别
>
> CountDownLatch和Semaphore的区别和底层原理
>
> Sychronized的偏向锁、轻量级锁、重量级锁
>
> Sychronized和ReentrantLock的区别
>
> 谈谈你对AQS的理解，AQS如何实现可重⼊锁？
>
> 开发框架()
>
> Spring是什么？
>
> 谈谈你对AOP的理解
>
> 谈谈你对IOC的理解
>
> 解释下Spring⽀持的⼏种bean的作⽤域。

2

> Spring事务的实现⽅式和原理以及隔离级别？
>
> Spring事务传播机制
>
> Spring事务什么时候会失效?
>
> 什么是bean的⾃动装配，有哪些⽅式？
>
> Spring中的Bean创建的⽣命周期有哪些步骤
>
> Spring中Bean是线程安全的吗
>
> ApplicationContext和BeanFactory有什么区别
>
> Spring中的事务是如何实现的
>
> Spring中什么时候@Transactional会失效
>
> Spring容器启动流程是怎样的
>
> Spring⽤到了哪些设计模式
>
> Spring Boot、Spring MVC 和 Spring 有什么区别
>
> Spring MVC ⼯作流程
>
> Spring MVC的主要组件？
>
> Spring Boot ⾃动配置原理？
>
> 如何理解 Spring Boot 中的 Starter
>
> 什么是嵌⼊式服务器？为什么要使⽤嵌⼊式服务器?
>
> Spring Boot中常⽤注解及其底层实现
>
> Spring Boot是如何启动Tomcat的
>
> Spring Boot中配置⽂件的加载顺序是怎样的？
>
> Mybatis的优缺点
>
> MyBatis 与Hibernate 有哪些不同？
>
> #{}和\${}的区别是什么？
>
> 简述 Mybatis 的插件运⾏原理，如何编写⼀个插件。
>
> Mysql()
>
> 索引的基本原理
>
> Mysql聚簇和⾮聚簇索引的区别
>
> Mysql索引的数据结构，各⾃优劣
>
> 索引设计的原则？
>
> InnoDB存储引擎的锁的算法
>
> 关⼼过业务系统⾥⾯的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？ 事务的基本特性和隔离级别

3

> ACID靠什么保证的？
>
> 什么是MVCC
>
> 分表后⾮sharding_key的查询怎么处理，分表后的排序？ Mysql主从同步原理
>
> 简述MyISAM和InnoDB的区别
>
> 简述Mysql中索引类型及对数据库的性能的影响 Explain语句结果中各个字段分表表示什么
>
> 索引覆盖是什么
>
> 最左前缀原则是什么
>
> Innodb是如何实现事务的
>
> B树和B+树的区别，为什么Mysql使⽤B+树
>
> Mysql锁有哪些，如何理解
>
> Mysql慢查询该如何优化？
>
> Redis()
>
> 什么是RDB和AOF
>
> Redis的过期键的删除策略
>
> Redis线程模型、单线程快的原因
>
> 简述Redis事务实现
>
> Redis 主从复制的核⼼原理
>
> Redis有哪些数据结构？分别有哪些典型的应⽤场景？ Redis分布式锁底层是如何实现的？
>
> Redis主从复制的核⼼原理
>
> Redis集群策略
>
> 缓存穿透、缓存击穿、缓存雪崩分别是什么
>
> Redis和Mysql如何保证数据⼀致
>
> Redis的持久化机制
>
> Redis单线程为什么这么快
>
> 简述Redis事务实现
>
> 分布式与微服务()
>
> 什么是CAP理论
>
> 什么是BASE理论
>
> 什么是RPC

4

> 数据⼀致性模型有哪些
>
> 分布式ID是什么？有哪些解决⽅案？ 分布式锁的使⽤场景是什么？有哪些实现⽅案？ 什么是分布式事务？有哪些实现⽅案？ 什么是ZAB协议
>
> 简述paxos算法
>
> 简述raft算法
>
> 为什么Zookeeper可以⽤来作为注册中⼼ Zookeeper中的领导者选举的流程是怎样的？ Zookeeper集群中节点之间数据是如何同步的 Dubbo⽀持哪些负载均衡策略
>
> Dubbo是如何完成服务导出的？
>
> Dubbo是如何完成服务引⼊的？
>
> Dubbo的架构设计是怎样的？
>
> 负载均衡算法有哪些
>
> 分布式架构下，Session共享有什么⽅案 简述你对RPC、RMI的理解
>
> 如何实现接⼝的幂等性
>
> Zookeeper的数据模型和节点类型
>
> 简述zk的命名服务、配置管理、集群管理 讲下Zookeeper中的watch机制
>
> Zookeeper和Eureka的区别
>
> 如何实现分库分表
>
> 存储拆分后如何解决唯⼀主键问题
>
> 雪花算法原理
>
> 如何解决不使⽤分区键的查询问题
>
> SpringCloud有哪些常⽤组件，作⽤是什么？ 如何避免缓存穿透、缓存击穿、缓存雪崩？ 分布式系统中常⽤的缓存⽅案有哪些 缓存过期都有哪些策略？
>
> 常⻅的缓存淘汰算法
>
> 布隆过滤器原理，优缺点

5

> 分布式缓存寻址算法
>
> 什么是Hystrix？简述实现机制
>
> Spring Cloud和Dubbo有哪些区别？
>
> 什么是服务雪崩？什么是服务限流？
>
> 什么是服务熔断？什么是服务降级？区别是什么？ SOA、分布式、微服务之间有什么关系和区别？ 怎么拆分微服务？
>
> 怎样设计出⾼内聚、低耦合的微服务？
>
> 有没有了解过DDD领域驱动设计？
>
> 什么是中台？
>
> 你的项⽬中是怎么保证微服务敏捷开发的？ 消息队列()
>
> 如何进⾏产品选型？
>
> 简述RabbitMQ的架构设计
>
> RabbitMQ如何确保消息发送 ？ 消息接收？ RabbitMQ事务消息
>
> RabbitMQ死信队列、延时队列
>
> RabbitMQ镜像队列机制
>
> Kafka是什么
>
> Kafka为什么吞吐量⾼
>
> Kafka的Pull和Push分别有什么优缺点
>
> 为什么要使⽤ kafka，为什么要使⽤消息队列? Kafka中的ISR、AR⼜代表什么？ISR的伸缩⼜指什么 Kafka⾼效⽂件存储设计特点：
>
> Kafka与传统消息系统之间有三个关键区别
>
> Kafka创建 Topic 时如何将分区放置到不同的 Broker 中 Kafka的消费者如何消费数据
>
> Kafka消费者负载均衡策略
>
> kafaka⽣产数据时数据的分组策略
>
> Kafka中是怎么体现消息顺序性的？
>
> Kafka如何实现延迟队列？
>
> RocketMQ的事务消息是如何实现的

6

> 为什么RocketMQ不使⽤Zookeeper作为注册中⼼呢？ RocketMQ的实现原理
>
> RocketMQ为什么速度快
>
> 消息队列如何保证消息可靠传输
>
> 消息队列有哪些作⽤
>
> 死信队列是什么？延时队列是什么？
>
> 如何保证消息的⾼效读写？
>
> 让你设计⼀个MQ，你会如何设计？
>
> ⽹络()
>
> 什么是认证和授权？如何设计⼀个权限认证框架？ 如果没有Cookie,Session还能进⾏身份验证吗？ 什么是CSRF攻击？如何防⽌？
>
> 什么是OAuth.协议？有哪⼏种认证⽅式？ 什么是SSO？与OAuth.有什么关系？
>
> 如何设计⼀个开放授权平台？
>
> epoll和poll的区别
>
> TCP的三次握⼿和四次挥⼿
>
> 浏览器发出⼀个请求到收到响应经历了哪些步骤？ 跨域请求是什么？有什么问题？怎么解决？ 零拷⻉是什么
>
> Leetcode算法（）
>
> 反转链表
>
> 统计N以内的素数
>
> 寻找数组的中⼼索引
>
> 删除排序数组中的重复项
>
> x的平⽅根
>
> 三个数的最⼤乘积
>
> 两数之和
>
> 斐波那契数列
>
> 环形链表
>
> 排列硬币

7

> # Java基础(33)
>
> ## ⾯向对象
>
> 什么是⾯向对象？对⽐⾯向过程，是两种不同的处理问题的⻆度，⾯向过程更注重事情的每⼀个步骤及 顺序，⾯向对象更注重事情有哪些参与者（对象）、及各⾃需要什么，⽐如洗⾐机洗⾐服： ⾯向过程：会将任务拆解成⼀系列的步骤：打开洗⾐机\-\-\-\--\>放⾐服\-\-\-\--\>放洗⾐粉\-\-\-\--\>清 ●
>
> 洗\-\-\-\--\>烘⼲
>
> ⾯向对象：会拆出⼈和洗⾐机两个对象：
>
> ●
>
> a\. ⼈：打开洗⾐机 放⾐服 放洗⾐粉
>
> b\. 洗⾐机：清洗 烘⼲
>
> 从以上例⼦能看出，⾯向过程⽐较直接⾼效，⽽⾯向对象更易于复⽤、扩展和维护。
>
> 封装：封装的意义，在于明确标识出允许外部使⽤的所有成员函数和数据项，内部细节对外部调⽤透 明，外部调⽤⽆需修改或者关⼼内部实现
>
> 继承：继承基类的⽅法，并做出⾃⼰的改变和/或扩展，⼦类共性的⽅法或者属性直接使⽤⽗类的，⽽不 需要⾃⼰再定义，只需扩展⾃⼰个性化的
>
> 多态：基于对象所属类的不同，外部对同⼀个⽅法的调⽤，实际执⾏的逻辑不同
>
> JDK、JRE、JVM之间的区别
>
> JDK：Java Develpment Kit java 开发⼯具
>
> JRE：Java Runtime Environment java运⾏时环境
>
> JVM：java Virtual Machine java 虚拟机

8

> ![](media/image9.png){width="5.947916666666667in" height="3.4895844269466316in"}
>
> ==和equals⽅法之前的区别
>
> ==：对⽐的是栈中的值，基本数据类型是变量值，引⽤类型是堆中内存对象的地址 ●
>
> equals：object中默认也是采⽤==⽐较，通常会重写
>
> ●
>
> Object

Java 复制代码

1

2

3

String

public boolean equals(Object obj) { return (this == obj);

}

9

Java 复制代码

> 1
>
> public boolean equals(Object anObject) {
>
> 2
>
> if (this == anObject) {
>
> 3
>
> return true;
>
> 4
>
> }
>
> 5
>
> if (anObject instanceof String) {
>
> 6
>
> String anotherString = (String)anObject;
>
> 7
>
> int n = value.length;
>
> 8
>
> if (n == anotherString.value.length) {
>
> 9
>
> char v1\[\] = value;
>
> 10
>
> char v2\[\] = anotherString.value;
>
> 11
>
> int i = 0;
>
> 12
>
> while (n\-- != 0) {
>
> 13
>
> if (v1\[i\] != v2\[i\])
>
> 14
>
> return false;
>
> 15
>
> i++;
>
> 16
>
> }
>
> 17
>
> return true;
>
> 18
>
> }
>
> 19
>
> }
>
> 20
>
> return false;
>
> 21
>
> }
>
> 上述代码可以看出，String类中被复写的equals()⽅法其实是⽐较两个字符串的内容。 Java 复制代码
>
> 1
>
> public class StringDemo {
>
> 2
>
> public static void main(String args\[\]) {
>
> 3
>
> String str1 = \"Hello\";
>
> 4
>
> String str2 = new String(\"Hello\");
>
> 5
>
> String str3 = str2; // 引⽤传递
>
> 6
>
> System.out.println(str1 == str2); // false
>
> 7
>
> System.out.println(str1 == str3); // false
>
> 8
>
> System.out.println(str2 == str3); // true
>
> 9
>
> System.out.println(str1.equals(str2)); // true 10
>
> System.out.println(str1.equals(str3)); // true 11
>
> System.out.println(str2.equals(str3)); // true 12
>
> }
>
> 13
>
> }
>
> hashCode()与equals()之间的关系
>
> HashCode介绍：hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个int整数。这 个哈希码的作⽤是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，Java

10

> 中的任何类都包含有hashCode() 函数。
>
> 散列表存储的是键值对(key-value)，它的特点是：能根据"键"快速的检索出对应的"值"。这其中就利⽤ 到了散列码！（可以快速找到所需要的对象）
>
> 以"HashSet如何检查重复"为例⼦来说明为什么要有hashCode
>
> 对象加⼊HashSet时，HashSet会先计算对象的hashcode值来判断对象加⼊的位置，看该位置是否有 值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调⽤equals()⽅法来检 查两个对象是否真的相同。如果两者相同，HashSet就不会让其加⼊操作成功。如果不同的话，就会重 新散列到其他位置。这样就⼤⼤减少了equals的次数，相应就⼤⼤提⾼了执⾏速度。
>
> 如果两个对象相等，则hashcode⼀定也是相同的
>
> ●
>
> 两个对象相等,对两个对象分别调⽤equals⽅法都返回true
>
> ●
>
> 两个对象有相同的hashcode值，它们也不⼀定是相等的
>
> ●
>
> 因此，equals⽅法被覆盖过，则hashCode⽅法也必须被覆盖
>
> ●
>
> hashCode()的默认⾏为是对堆上的对象产⽣独特值。如果没有重写hashCode()，则该class的两个 ●
>
> 对象⽆论如何都不会相等（即使这两个对象指向相同的数据）
>
> final关键字的作⽤是什么？
>
> 修饰类：表示类不可被继承
>
> 修饰⽅法：表示⽅法不可被⼦类覆盖，但是可以重载
>
> 修饰变量：表示变量⼀旦被赋值就不可以更改它的值。
>
> 修饰成员变量：
>
> 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。 ●
>
> 如果final修饰的是成员变量，可以在⾮静态初始化块、声明该变量或者构造器中执⾏初始值。 ●
>
> 修饰局部变量：
>
> 系统不会为局部变量进⾏初始化，局部变量必须由程序员显示初始化。因此使⽤final修饰局部变量时， 即可以在定义时指定默认值（后⾯的代码不能对变量再赋值），也可以不指定默认值，⽽在后⾯的代码 中对final变量赋初值（仅⼀次）

11

Java 复制代码

> 1
>
> public class FinalVar {
>
> 2
>
> final static int a = 0;//再声明的时候就需要赋值 或者静态代码块赋值 3
>
> /\*\*
>
> 4
>
> static{
>
> 5
>
> a = 0;
>
> 6
>
> }
>
> 7
>
> \*/
>
> 8
>
> final int b = 0;//再声明的时候就需要赋值 或者代码块中赋值 或者构造器赋值 9
>
> /\*{
>
> 10
>
> b = 0;
>
> 11
>
> }\*/
>
> 12
>
> public static void main(String\[\] args) {
>
> 13
>
> final int localA; //局部变量只声明没有初始化，不会报错,与final⽆关。 14
>
> localA = 0;//在使⽤之前⼀定要赋值
>
> 15
>
> //localA = 1; 但是不允许第⼆次赋值
>
> 16
>
> }
>
> 17
>
> }
>
> 修饰基本类型数据和引⽤类型数据：
>
> 如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；
>
> ●
>
> 如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。但是引⽤的值是可变 ●
>
> 的。

Java 复制代码

1

2

3

4

5

6

7

8

9

10 11

public class FinalReferenceTest{ public static void main(){

final int\[\] iArr={1,2,3,4};

iArr\[2\]=-3;//合法

iArr=null;//⾮法，对iArr不能重新赋值

final Person p = new Person(25); p.setAge(24);//合法

p=null;//⾮法

}

}

> 为什么局部内部类和匿名内部类只能访问局部final变量？ 编译之后会⽣成两个class⽂件，Test.class Test1.class

12

Java 复制代码

> 1
>
> public class Test {
>
> 2
>
> public static void main(String\[\] args) {
>
> 3
>
> }
>
> 4
>
> //局部final变量a,b
>
> 5
>
> public void test(final int b) {//jdk8在这⾥做了优化, 不⽤写,语法糖，但实际上也是 有的，也不能修改
>
> 6
>
> final int a = 10;
>
> 7
>
> //匿名内部类
>
> 8
>
> new Thread(){
>
> 9
>
> public void run() {
>
> 10
>
> System.out.println(a);
>
> 11
>
> System.out.println(b);
>
> 12
>
> };
>
> 13
>
> }.start();
>
> 14
>
> }
>
> 15
>
> }
>
> 16
>
> 17
>
> class OutClass {
>
> 18
>
> private int age = 12;
>
> 19
>
> 20
>
> public void outPrint(final int x) {
>
> 21
>
> class InClass {
>
> 22
>
> public void InPrint() {
>
> 23

System.out.println(x);

> 24

System.out.println(age);

> 25
>
> }
>
> 26
>
> }
>
> 27
>
> new InClass().InPrint();
>
> 28
>
> }
>
> 29
>
> }
>
> ⾸先需要知道的⼀点是: 内部类和外部类是处于同⼀个级别的，内部类不会因为定义在⽅法中就会随着 ⽅法的执⾏完毕就被销毁。
>
> 这⾥就会产⽣问题：当外部类的⽅法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有 没有⼈再引⽤它时，才会死亡)。这⾥就出现了⼀个⽭盾：内部类对象访问了⼀个不存在的变量。为了解 决这个问题，就将局部变量复制了⼀份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以 访问它，实际访问的是局部变量的\"copy\"。这样就好像延⻓了局部变量的⽣命周期
>
> 将局部变量复制为内部类的成员变量时，必须保证这两个变量是⼀样的，也就是如果我们在内部类中修 改了成员变量，⽅法中的局部变量也得跟着改变，怎么解决问题呢？

13

> 就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量 和⽅法的局部变量的⼀致性。这实际上也是⼀种妥协。使得局部变量与内部类内建⽴的拷⻉保持⼀致。
>
> String、StringBuffer、StringBuilder的区别
>
> 1\. String是不可变的，如果尝试去修改，会新⽣成⼀个字符串对象，StringBuffer和StringBuilder是 可变的
>
> 2\. StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效 率会更⾼
>
> 重载和重写的区别
>
> 1\. 重载： 发⽣在同⼀个类中，⽅法名必须相同，参数类型不同、个数不同、顺序不同，⽅法返回值和 访问修饰符可以不同，发⽣在编译时。
>
> 2\. 重写： 发⽣在⽗⼦类中，⽅法名、参数列表必须相同，返回值范围⼩于等于⽗类，抛出的异常范围 ⼩于等于⽗类，访问修饰符范围⼤于等于⽗类；如果⽗类⽅法访问修饰符为private则⼦类就不能重 写该⽅法。

Java 复制代码

> 1
>
> public int add(int a,String b) 2
>
> public String add(int a,String b) 3
>
> //编译报错
>
> 接⼝和抽象类的区别
>
> 抽象类可以存在普通成员函数，⽽接⼝中只能存在public abstract ⽅法。
>
> ●
>
> 抽象类中的成员变量可以是各种类型的，⽽接⼝中的成员变量只能是public static final类型的。 ●
>
> 抽象类只能继承⼀个，接⼝可以实现多个。
>
> ●
>
> 接⼝的设计⽬的，是对类的⾏为进⾏约束（更准确的说是⼀种"有"约束，因为接⼝不能规定类不可以有 什么⾏为），也就是提供⼀种机制，可以强制要求不同的类具有相同的⾏为。它只约束了⾏为的有⽆， 但不对如何实现⾏为进⾏限制。

14

> ⽽抽象类的设计⽬的，是代码复⽤。当不同的类具有某些相同的⾏为(记为⾏为集合A)，且其中⼀部分⾏ 为的实现⽅式⼀致时（A的⾮真⼦集，记为B），可以让这些类都派⽣于⼀个抽象类。在这个抽象类中实 现了B，避免让所有的⼦类来实现B，这就达到了代码复⽤的⽬的。⽽A减B的部分，留给各个⼦类⾃⼰ 实现。正是因为A-B在这⾥没有实现，所以抽象类不允许实例化出来（否则当调⽤到A-B时，⽆法执 ⾏）。
>
> 抽象类是对类本质的抽象，表达的是 is a 的关系，⽐如： BMW is a Car 。抽象类包含并实现⼦类的通 ⽤特性，将⼦类存在差异化的特性进⾏抽象，交由⼦类去实现。
>
> ⽽接⼝是对⾏为的抽象，表达的是 like a 的关系。⽐如： Bird like a Aircraft （像⻜⾏器⼀样可 以⻜），但其本质上 is a Bird 。接⼝的核⼼是定义⾏为，即实现类可以做什么，⾄于实现类主体是 谁、是如何实现的，接⼝并不关⼼。
>
> 使⽤场景：当你关注⼀个事物的本质的时候，⽤抽象类；当你关注⼀个操作的时候，⽤接⼝。
>
> 抽象类的功能要远超过接⼝，但是，定义抽象类的代价⾼。因为⾼级语⾔来说（从实际设计上来说也 是）每个类只能继承⼀个类。在这个类中，你必须继承或编写出其所有⼦类的所有共性。虽然接⼝在功 能上会弱化许多，但是它只是针对⼀个动作的描述。⽽且你可以在⼀个类中同时实现多个接⼝。在设计 阶段会降低难度
>
> List和Set的区别
>
> List：有序，按对象进⼊的顺序保存对象，可重复，允许多个Null元素对象，可以使⽤Iterator取出 ●
>
> 所有元素，在逐⼀遍历，还可以使⽤get(int index)获取指定下标的元素
>
> Set：⽆序，不可重复，最多允许有⼀个Null元素对象，取元素时只能⽤Iterator接⼝取得所有元 ●
>
> 素，在逐⼀遍历各个元素
>
> ArrayList和LinkedList区别
>
> 1\. ⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实 现的
>
> 2\. 由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合 删除和添加，查询、添加、删除的时间复杂度不同
>
> 3\. 另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以

15

> LinkedList还可以当做队列来使⽤
>
> HashMap和HashTable有什么区别？其底层实现是什么？
>
> 区别 ：
>
> 1\. HashMap⽅法没有synchronized修饰，线程⾮安全，HashTable线程安全； 2. HashMap允许key和value为null，⽽HashTable不允许
>
> 底层实现：数组+链表实现，jdk8开始链表⾼度到8、数组⻓度超过64，链表转变为红⿊树，元素以内部 类Node节点存在
>
> 1\. 计算key的hash值，⼆次hash然后对数组⻓度取模，对应到数组下标，
>
> 2\. 如果没有产⽣hash冲突(下标位置没有元素)，则直接创建Node存⼊数组，
>
> 3\. 如果产⽣hash冲突，先进⾏equal⽐较，相同则取代该元素，不同，则判断链表⾼度插⼊链表，链 表⾼度达到8，并且数组⻓度到64则转变为红⿊树，⻓度低于6则将红⿊树转回链表 4. key为null，存在下标0的位置
>
> 谈谈ConcurrentHashMap的扩容机制
>
> 1.7版本
>
> 1\. 1.7版本的ConcurrentHashMap是基于Segment分段实现的
>
> 2\. 每个Segment相对于⼀个⼩型的HashMap
>
> 3\. 每个Segment内部会进⾏扩容，和HashMap的扩容逻辑类似
>
> 4\. 先⽣成新的数组，然后转移元素到新数组中
>
> 5\. 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值
>
> 1.8版本
>
> 1\. 1.8版本的ConcurrentHashMap不再基于Segment实现
>
> 2\. 当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容 3. 如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然 后判断是否超过阈值，超过了则进⾏扩容
>
> 4\. ConcurrentHashMap是⽀持多个线程同时扩容的
>
> 5\. 扩容之前也先⽣成⼀个新的数组
>
> 6\. 在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或 多组的元素转移⼯作

16

> Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)? 1. 1.7中底层是数组+链表，1.8中底层是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和 查询整体效率
>
> 2\. 1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要 判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法 3. 1.7中哈希算法⽐较复杂，存在各种右移与异或运算，1.8中进⾏了简化，因为复杂的哈希算法的⽬的 就是提⾼散列性，来提供HashMap的整体效率，⽽1.8中新增了红⿊树，所以可以适当的简化哈希 算法，节省CPU资源
>
> 说⼀下HashMap的Put⽅法
>
> 先说HashMap的Put⽅法的⼤体流程：
>
> 1\. 根据Key通过哈希算法与与运算得出数组下标
>
> 2\. 如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中 是Node对象）并放⼊该位置
>
> 3\. 如果数组下标位置元素不为空，则要分情况讨论
>
> a\. 如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry 对象，并使⽤头插法添加到当前位置的链表中
>
> b\. 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红⿊树Node，还是链表Node ⅰ. 如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个 过程中会判断红⿊树中是否存在当前key，如果存在则更新value
>
> ⅱ. 如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过尾插 法插⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会 判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链 表中，插⼊到链表后，会看当前链表的节点个数，如果⼤于等于8，那么则会将该链表转 成红⿊树
>
> ⅲ. 将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要 就扩容，如果不需要就结束PUT⽅法
>
> 泛型中extends和super的区别
>
> 1\. \<? extends T\>表示包括T在内的任何T的⼦类
>
> 2\. \<? super T\>表示包括T在内的任何T的⽗类

17

> 深拷⻉和浅拷⻉
>
> 深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实 例对象的引⽤。
>
> 1\. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所 指向的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象
>
> 2\. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制， 深拷⻉出来的对象，内部的属性指向的不是同⼀个对象
>
> HashMap的扩容机制原理
>
> 1.7版本
>
> 1\. 先⽣成新数组
>
> 2\. 遍历⽼数组中的每个位置上的链表上的每个元素
>
> 3\. 取每个元素的key，并基于新数组⻓度，计算出每个元素在新数组中的下标
>
> 4\. 将元素添加到新数组中去
>
> 5\. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性
>
> 1.8版本
>
> 1\. 先⽣成新数组
>
> 2\. 遍历⽼数组中的每个位置上的链表或红⿊树
>
> 3\. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去 4. 如果是红⿊树，则先遍历红⿊树，先计算出红⿊树中每个元素对应在新数组中的下标位置 a. 统计每个下标位置的元素个数
>
> b\. 如果该位置下的元素个数超过了8，则⽣成⼀个新的红⿊树，并将根节点的添加到新数组的对 应位置
>
> c\. 如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的头节点添加到新数组 的对应位置
>
> 5\. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性
>
> CopyOnWriteArrayList的底层原理是怎样的
>
> 1\. ⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素 时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏
>
> 2\. 并且，写操作会加锁，防⽌出现并发写⼊丢失数据的问题
>
> 3\. 写操作结束之后会把原数组指向新数组
>
> 4\. CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应 ⽤场景，但是CopyOnWriteArrayList会⽐较占内存，同时可能读到的数据不是实时最新的数据，所 以不适合实时性要求很⾼的场景

18.什么是字节码？采⽤字节码的好处是什么？

> Java中的编译器和解释器：Java中引⼊了虚拟机的概念，即在机器和编译程序之间加⼊了⼀层抽象的虚 拟的机器。这台虚拟的机器在任何平台上都提供给编译程序⼀个的共同的接⼝。编译程序只需要⾯向虚 拟机，⽣成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执⾏。在 Java中，这种供虚拟机理解的代码叫做 字节码（即扩展名为 .class的⽂件），它不⾯向任何特定的处理 器，只⾯向虚拟机。
>
> 每⼀种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节 码，字节码由虚拟机解释执⾏，虚拟机将每⼀条要执⾏的字节码送给解释器，解释器将其翻译成特定机 器上的机器码，然后在特定的机器上运⾏。这也就是解释了Java的编译与解释并存的特点。
>
> Java源代码\-\-\--\>编译器\-\-\--\>jvm可执⾏的Java字节码(即虚拟指令)\-\-\--\>jvm\-\-\--\>jvm中解释器\-- \-\--\>机器可执⾏的⼆进制机器码\-\-\--\>程序运⾏。
>
> 采⽤字节码的好处：Java语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问 题，同时⼜保留了解释型语⾔可移植的特点。所以Java程序运⾏时⽐较⾼效，⽽且，由于字节码并不专 对⼀种特定的机器，因此，Java程序⽆须重新编译便可在多种不同的计算机上运⾏。
>
> Java中的异常体系是怎样的
>
> Java中的所有异常都来⾃顶级⽗类Throwable。
>
> ●
>
> Throwable下有两个⼦类Exception和Error。
>
> ●
>
> Error是程序⽆法处理的错误，⼀旦出现这个错误，则程序将被迫停⽌运⾏。
>
> ●
>
> Exception不会导致程序停⽌，⼜分为两个部分RunTimeException运⾏时异常和 ●
>
> CheckedException检查异常。
>
> RunTimeException常常发⽣在程序运⾏过程中，会导致程序当前线程执⾏失败。 ●
>
> CheckedException常常发⽣在程序编译过程中，会导致程序编译不通过。
>
> Java中有哪些类加载器
>
> JDK⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。

19

> BootStrapClassLoader是ExtClassLoader的⽗类加载器，默认负责加载%JAVA_HOME%lib下的 ●
>
> jar包和class⽂件。
>
> ExtClassLoader是AppClassLoader的⽗类加载器，负责加载%JAVA_HOME%/lib/ext⽂件夹下的 ●
>
> jar包和class类。
>
> AppClassLoader是⾃定义类加载器的⽗类，负责加载classpath下的类⽂件。 ●
>
> 说说类加载器双亲委派模型
>
> JVM中存在三个默认的类加载器：
>
> 1\. BootstrapClassLoader
>
> 2\. ExtClassLoader
>
> 3\. AppClassLoader
>
> AppClassLoader的⽗加载器是ExtClassLoader，ExtClassLoader的⽗加载器是 BootstrapClassLoader。
>
> JVM在加载⼀个类时，会调⽤AppClassLoader的loadClass⽅法来加载这个类，不过在这个⽅法中，会 先使⽤ExtClassLoader的loadClass⽅法来加载类，同样ExtClassLoader的loadClass⽅法中会先使⽤ BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果 BootstrapClassLoader没有加载到，那么ExtClassLoader就会⾃⼰尝试加载该类，如果没有加载到， 那么则会由AppClassLoader来加载这个类。
>
> 所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进⾏加载，如果没加载到才由⾃⼰ 进⾏加载。
>
> GC如何判断对象可以被回收
>
> 引⽤计数法：每个对象有⼀个引⽤计数属性，新增⼀个引⽤时计数加1，引⽤释放时计数减1，计数 ●
>
> 为0时可以回收，
>
> 可达性分析法：从 GC Roots 开始向下搜索，搜索所⾛过的路径称为引⽤链。当⼀个对象到 GC ●
>
> Roots 没有任何引⽤链相连时，则证明此对象是不可⽤的，那么虚拟机就判断是可回收对象。
>
> 引⽤计数法，可能会出现A 引⽤了 B，B ⼜引⽤了 A，这时候就算他们都不再使⽤了，但因为相互引 ⽤ 计数器=1 永远⽆法被回收。

20

> GC Roots的对象有：
>
> 虚拟机栈(栈帧中的本地变量表）中引⽤的对象
>
> ●
>
> ⽅法区中类静态属性引⽤的对象
>
> ●
>
> ⽅法区中常量引⽤的对象
>
> ●
>
> 本地⽅法栈中JNI(即⼀般说的Native⽅法)引⽤的对象
>
> ●
>
> 可达性算法中的不可达对象并不是⽴即死亡的，对象拥有⼀次⾃我拯救的机会。对象被系统宣告死亡⾄ 少要经历两次标记过程：第⼀次是经过可达性分析发现没有与GC Roots相连接的引⽤链，第⼆次是在 由虚拟机⾃动建⽴的Finalizer队列中判断是否需要执⾏finalize()⽅法。
>
> 当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize⽅法，若未覆盖，则直接将其回 收。否则，若对象未执⾏过finalize⽅法，将其放⼊F-Queue队列，由⼀低优先级线程执⾏该队列中对 象的finalize⽅法。执⾏finalize⽅法完毕后，GC会再次判断该对象是否可达，若不可达，则进⾏回收， 否则，对象"复活"
>
> 每个对象只能触发⼀次finalize()⽅法
>
> 由于finalize()⽅法运⾏代价⾼昂，不确定性⼤，⽆法保证各个对象的调⽤顺序，不推荐⼤家使⽤，建议 遗忘它。
>
> JVM中哪些是线程共享区
>
> 堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的

21

> ![](media/image2.png){width="5.583333333333333in" height="3.9791666666666665in"}
>
> 你们项⽬如何排查JVM问题
>
> 对于还在正常运⾏的系统：
>
> 1\. 可以使⽤jmap来查看JVM中各个区域的使⽤情况
>
> 2\. 可以通过jstack来查看线程的运⾏情况，⽐如哪些线程阻塞、是否出现了死锁 3. 可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc⽐较频繁，那么就得进⾏ 调优了
>
> 4\. 通过各个命令的结果，或者jvisualvm等⼯具来进⾏分析
>
> 5\. ⾸先，初步猜测频繁发送fullgc的原因，如果频繁发⽣fullgc但是⼜⼀直没有出现内存溢出，那么表 示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免 这些对象进⼊到⽼年代，对于这种情况，就要考虑这些存活时间不⻓的对象是不是⽐较⼤，导致年 轻代放不下，直接进⼊到了⽼年代，尝试加⼤年轻代的⼤⼩，如果改完之后，fullgc减少，则证明 修改有效
>
> 6\. 同时，还可以找到占⽤CPU最多的线程，定位到具体的⽅法，优化这个⽅法的执⾏，看是否能避免 某些对象的创建，从⽽节省内存
>
> 对于已经发⽣了OOM的系统：
>
> 1\. ⼀般⽣产系统中都会设置当系统发⽣了OOM时，⽣成当时的dump⽂件（-
>
> XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base）

22

> 2\. 我们可以利⽤jsisualvm等⼯具来分析dump⽂件
>
> 3\. 根据dump⽂件找到异常的实例对象，和异常的线程（占⽤CPU⾼），定位到具体的代码 4. 然后再进⾏详细的分析和调试
>
> 总之，调优不是⼀蹴⽽就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题
>
> ⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？ 1. ⽤户创建⼀个对象，JVM⾸先需要到⽅法区去找对象的类型信息。然后再创建对象。 2. JVM要实例化⼀个对象，⾸先要在堆当中先创建⼀个对象。-\> 半初始化状态 3. 对象⾸先会分配在堆内存中新⽣代的Eden。然后经过⼀次Minor GC，对象如果存活，就会进⼊S
>
> 区。在后续的每次GC中，如果对象⼀直存活，就会在S区来回拷⻉，每移动⼀次，年龄加1。-\> 多 ⼤年龄才会移⼊⽼年代？ 年龄最⼤15， 超过⼀定年龄后，对象转⼊⽼年代。 4. 当⽅法执⾏结束后，栈中的指针会先移除掉。
>
> 5\. 堆中的对象，经过Full GC，就会被标记为垃圾，然后被GC线程清理掉。
>
> 怎么确定⼀个对象到底是不是垃圾？
>
> 1\. 引⽤计数： 这种⽅式是给堆内存当中的每个对象记录⼀个引⽤个数。引⽤个数为0的就认为是垃 圾。这是早期JDK中使⽤的⽅式。引⽤计数⽆法解决循环引⽤的问题。
>
> 2\. 根可达算法： 这种⽅式是在内存中，从引⽤根对象向下⼀直找引⽤，找不到的对象就是垃圾。
>
> JVM有哪些垃圾回收算法？
>
> 1\. MarkSweep 标记清除算法：这个算法分为两个阶段，标记阶段：把垃圾内存标记出来，清除阶 段：直接将垃圾内存回收。这种算法是⽐较简单的，但是有个很严重的问题，就是会产⽣⼤量的内 存碎⽚。
>
> 2\. Copying 拷⻉算法：为了解决标记清除算法的内存碎⽚问题，就产⽣了拷⻉算法。拷⻉算法将内存 分为⼤⼩相等的两半，每次只使⽤其中⼀半。垃圾回收时，将当前这⼀块的存活对象全部拷⻉到另 ⼀半，然后当前这⼀半内存就可以直接清除。这种算法没有内存碎⽚，但是他的问题就在于浪费空 间。⽽且，他的效率跟存货对象的个数有关。
>
> 3\. MarkCompack 标记压缩算法：为了解决拷⻉算法的缺陷，就提出了标记压缩算法。这种算法在标 记阶段跟标记清除算法是⼀样的，但是在完成标记之后，不是直接清理垃圾内存，⽽是将存活对象 往⼀端移动，然后将端边界以外的所有内存直接清除。

23

> 这三种算法各有利弊，各⾃有各⾃的适合场景。
>
> 什么是STW？
>
> STW: Stop-The-World，是在垃圾回收算法执⾏过程当中，需要将JVM内存冻结的⼀种状态。在STW 状态下，JAVA的所有线程都是停⽌执⾏的-GC线程除外，native⽅法可以执⾏，但是，不能与JVM交 互。GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。
>
> JVM有哪些垃圾回收器？
>
> 新⽣代收集器：
>
> ●
>
> Serial
>
> ○
>
> ParNew
>
> ○
>
> Parallel Scavenge
>
> ○
>
> ⽼年代收集器：
>
> ●
>
> CMS
>
> ○
>
> Serial Old
>
> ○
>
> Parallel Old
>
> ○
>
> 整堆收集器：
>
> ●
>
> G1
>
> ○
>
> 垃圾回收分为哪些阶段
>
> GC分为四个阶段：
>
> 第⼀：初始标记 标记出GCRoot直接引⽤的对象。STW
>
> ●
>
> 第⼆：标记Region，通过RSet标记出上⼀个阶段标记的Region引⽤到的Old区Region。 ●
>
> 第三：并发标记阶段：跟CMS的步骤是差不多的。只是遍历的范围不再是整个Old区，⽽只需要遍 ●
>
> 历第⼆步标记出来的Region。
>
> 第四：重新标记： 跟CMS中的重新标记过程是差不多的。
>
> ●
>
> 第五：垃圾清理：与CMS不同的是，G1可以采⽤拷⻉算法，直接将整个Region中的对象拷⻉到另 ●
>
> ⼀个Region。⽽这个阶段，G1只选择垃圾较多的Region来清理，并不是完全清理。

24

> 什么是三⾊标记？
>
> 三⾊标记：是⼀种逻辑上的抽象。将每个内存对象分成三种颜⾊：
>
> 1\. ⿊⾊：表示⾃⼰和成员变量都已经标记完毕。
>
> 2\. 灰⾊：⾃⼰标记完了，但是成员变量还没有完全标记完。
>
> 3\. ⽩⾊：⾃⼰未标记完。
>
> JVM参数有哪些？
>
> JVM参数⼤致可以分为三类：
>
> 1\. 标注指令： -开头，这些是所有的HotSpot都⽀持的参数。可以⽤java -help 打印出来。 2. ⾮标准指令： -X开头，这些指令通常是跟特定的HotSpot版本对应的。可以⽤java -X 打印出来。 3. 不稳定参数： -XX 开头，这⼀类参数是跟特定HotSpot版本对应的，并且变化⾮常⼤。详细的⽂档 资料⾮常少。在JDK1.8版本下，有⼏个常⽤的不稳定指令：

java -XX:+PrintCommandLineFlags ： 查看当前命令的不稳定指令。

java -XX:+PrintFlagsInitial ： 查看所有不稳定指令的默认值。

java -XX:+PrintFlagsFinal： 查看所有不稳定指令最终⽣效的实际值。

> Java并发(20)
>
> 线程的⽣命周期？线程有⼏种状态
>
> 线程通常有五种状态，创建，就绪，运⾏、阻塞和死亡状态：
>
> 1\. 新建状态（New）：新创建了⼀个线程对象。
>
> 2\. 就绪状态（Runnable）：线程对象创建后，其他线程调⽤了该对象的start⽅法。该状态的线程位于 可运⾏线程池中，变得可运⾏，等待获取CPU的使⽤权。
>
> 3\. 运⾏状态（Running）：就绪状态的线程获取了CPU，执⾏程序代码。
>
> 4\. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使⽤权，暂时停⽌运⾏。直到线程 进⼊就绪状态，才有机会转到运⾏状态。

25

> 5\. 死亡状态（Dead）：线程执⾏完了或者因异常退出了run⽅法，该线程结束⽣命周期。
>
> 阻塞的情况⼜分为三种：
>
> 1\. 等待阻塞：运⾏的线程执⾏wait⽅法，该线程会释放占⽤的所有资源，JVM会把该线程放⼊"等待 池"中。进⼊这个状态后，是不能⾃动唤醒的，必须依靠其他线程调⽤notify或notifyAll⽅法才能被 唤醒，wait是object类的⽅法
>
> 2\. 同步阻塞：运⾏的线程在获取对象的同步锁时，若该同步锁被别的线程占⽤，则JVM会把该线程放 ⼊"锁池"中。
>
> 3\. 其他阻塞：运⾏的线程执⾏sleep或join⽅法，或者发出了I/O请求时，JVM会把该线程置为阻塞状 态。当sleep状态超时、join等待线程终⽌或者超时、或者I/O处理完毕时，线程重新转⼊就绪状 态。sleep是Thread类的⽅法
>
> sleep()、wait()、join()、yield()之间的的区别
>
> 锁池：所有需要竞争同步锁的线程都会放在锁池当中，⽐如当前对象的锁已经被其中⼀个线程得到，则 其他线程需要在这个锁池进⾏等待，当前⾯的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线 程得到后会进⼊就绪队列进⾏等待cpu资源分配。
>
> 等待池：当我们调⽤wait（）⽅法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只 有调⽤了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出⼀ 个线程放到锁池，⽽notifyAll()是将等待池的所有线程放到锁池当中
>
> 1\. sleep 是 Thread 类的静态本地⽅法，wait 则是 Object 类的本地⽅法。
>
> 2\. sleep⽅法不会释放lock，但是wait会释放，⽽且会加⼊到等待队列中。

Plain Text 复制代码

> 1
>
> sleep就是把cpu的执⾏资格和执⾏权释放出去，不再运⾏此线程，当定时时间结束再取回cpu资源，参与 cpu的调度，获取到cpu资源后就可以继续运⾏了。⽽如果sleep时该线程有锁，那么sleep不会释放这个 锁，⽽是把锁带着进⼊了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说 ⽆法执⾏程序。如果在睡眠期间其他线程调⽤了这个线程的interrupt⽅法，那么这个线程也会抛出 interruptexception异常返回，这点和wait是⼀样的。
>
> 3\. sleep⽅法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。 4. sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别⼈中断）。 5. sleep ⼀般⽤于当前线程休眠，或者轮循暂停操作，wait 则多⽤于多线程之间的通信。 6. sleep 会让出 CPU 执⾏时间且强制上下⽂切换，⽽ wait 则不⼀定，wait 后可能还是有机会重新竞 争到锁继续执⾏的。

7\. yield（）执⾏后线程直接进⼊就绪状态，⻢上释放了cpu的执⾏权，但是依然保留了cpu的执⾏资

26

> 格，所以有可能cpu下次进⾏线程调度还会让这个线程获取到执⾏权继续执⾏ 8. join（）执⾏后线程进⼊阻塞状态，例如在线程B中调⽤线程A的join（），那线程B会进⼊到阻塞队 列，直到线程A结束或中断线程

Java 复制代码

> 1
>
> public static void main(String\[\] args) throws InterruptedException { 2
>
> Thread t1 = new Thread(new Runnable() {
>
> 3
>
> \@Override
>
> 4
>
> public void run() {
>
> 5
>
> try {
>
> 6
>
> Thread.sleep(3000);
>
> 7
>
> } catch (InterruptedException e) {
>
> 8
>
> e.printStackTrace();
>
> 9
>
> }
>
> 10
>
> System.out.println(\"22222222\");
>
> 11
>
> }
>
> 12
>
> });
>
> 13
>
> t1.start();
>
> 14
>
> t1.join();
>
> 15
>
> // 这⾏代码必须要等t1全部执⾏完毕，才会执⾏
>
> 16
>
> System.out.println(\"1111\");
>
> 17
>
> }
>
> 18
>
> 19
>
> 22222222
>
> 20
>
> 1111
>
> 对线程安全的理解
>
> 不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问，当多个线程访问⼀个对象时， 如果不⽤进⾏额外的同步控制或其他的协调操作，调⽤这个对象的⾏为都可以获得正确的结果，我们就 说这个对象是线程安全的。
>
> 堆是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是⽤户分 配的空间。堆在操作系统对进程初始化的时候分配，运⾏过程中也可以向系统要额外的堆，但是⽤完了 要还给操作系统，要不然就是内存泄漏。在Java中，堆是Java虚拟机所管理的内存中最⼤的⼀块，是所
>
> 有线程共享的⼀块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯⼀⽬的就是存放对象实 例，⼏乎所有的对象实例以及数组都在这⾥分配内存。
>
> 栈是每个线程独有的，保存其运⾏状态和局部⾃动变量的。栈在线程开始的时候初始化，每个线程的栈 互相独⽴，因此，栈是线程安全的。操作系统在切换线程的时候会⾃动切换栈。栈空间不需要在⾼级语 ⾔⾥⾯显式的分配和释放。

27

> ⽬前主流操作系统都是多任务的，即多个进程同时运⾏。为了保证安全，每个进程只能访问分配给⾃⼰ 的内存空间，⽽不能访问别的进程的，这是由操作系统保障的。
>
> 在每个进程的内存空间中都会有⼀块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以 访问到该区域，这就是造成问题的潜在原因。
>
> Thread和Runable的区别
>
> Thread和Runnable的实质是继承关系，没有可⽐性。⽆论使⽤Runnable还是Thread，都会new Thread，然后执⾏run⽅法。⽤法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简 单的执⾏⼀个任务，那就实现runnable。

Java 复制代码

> 1
>
> //会卖出多⼀倍的票
>
> 2
>
> public class Test {
>
> 3
>
> public static void main(String\[\] args) {
>
> 4
>
> // TODO Auto-generated method stub
>
> 5
>
> 6
>
> new MyThread().start();
>
> 7
>
> new MyThread().start();
>
> 8
>
> 9
>
> }
>
> 10
>
> 11
>
> 12
>
> static class MyThread extends Thread{
>
> 13
>
> private int ticket = 5;
>
> 14
>
> public void run(){
>
> 15
>
> while(true){
>
> 16

System.out.println(\"Thread ticket = \" + ticket\--);

> 17
>
> if(ticket \< 0){
>
> 18
>
> break;
>
> 19
>
> }
>
> 20
>
> }
>
> 21
>
> }
>
> 22
>
> }
>
> 23
>
> }

28

Java 复制代码

> 1
>
> //正常卖出
>
> 2
>
> public class Test2 {
>
> 3
>
> public static void main(String\[\] args) {
>
> 4
>
> // TODO Auto-generated method stub
>
> 5
>
> MyThread2 mt=new MyThread2();
>
> 6
>
> new Thread(mt).start();
>
> 7
>
> new Thread(mt).start();
>
> 8
>
> 9
>
> 10
>
> }
>
> 11
>
> static class MyThread2 implements Runnable{
>
> 12
>
> private int ticket = 5;
>
> 13
>
> public void run(){
>
> 14
>
> while(true){
>
> 15

System.out.println(\"Runnable ticket = \" + ticket\--);

> 16
>
> if(ticket \< 0){
>
> 17
>
> break;
>
> 18
>
> }
>
> 19
>
> }
>
> 20
>
> }
>
> 21
>
> }
>
> 22
>
> }
>
> 原因是：MyThread创建了两个实例，⾃然会卖出两倍，属于⽤法错误
>
> 对守护线程的理解
>
> 守护线程：为所有⾮守护线程提供服务的线程；任何⼀个守护线程都是整个JVM中所有⾮守护线程的保 姆；
>
> 守护线程类似于整个进程的⼀个默默⽆闻的⼩喽喽；它的⽣死⽆关重要，它却依赖整个进程⽽运⾏；哪 天其他线程结束了，没有要执⾏的了，程序就结束了，理都没理守护线程，就把它中断了；
>
> 注意： 由于守护线程的终⽌是⾃身⽆法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因 为它不靠谱；
>
> 守护线程的作⽤是什么？
>
> 举例， GC垃圾回收线程：就是⼀个经典的守护线程，当我们的程序中不再有任何运⾏的Thread,程序就 不会再产⽣垃圾，垃圾回收器也就⽆事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线 程会⾃动离开。它始终在低级别的状态中运⾏，⽤于实时监控和管理系统中的可回收资源。

29

> 应⽤场景：（1）来为其它线程提供服务⽀持的情况；（2） 或者在任何情况下，程序结束时，这个线程 必须正常且⽴刻关闭，就可以作为守护线程来使⽤；反之，如果⼀个正在执⾏某个操作的线程必须要正 确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，⽽是⽤户线程。通常都是 些关键的事务，⽐⽅说，数据库录⼊或者更新，这些操作都是不能中断的。
>
> thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出⼀个IllegalThreadStateException 异常。你不能把正在运⾏的常规线程设置为守护线程。
>
> 在Daemon线程中产⽣的新线程也是Daemon的。
>
> 守护线程不能⽤于去访问固有资源，⽐如读写操作或者计算逻辑。因为它会在任何时候甚⾄在⼀个操作 的中间发⽣中断。
>
> Java⾃带的多线程框架，⽐如ExecutorService，会将守护线程转换为⽤户线程，所以如果要使⽤后台 线程就不能⽤Java的线程池。
>
> ThreadLocal的底层原理
>
> 1\. ThreadLocal是Java中所提供的线程本地存储机制，可以利⽤该机制将数据缓存在某个线程内部， 该线程可以在任意时刻、任意⽅法中获取缓存的数据
>
> 2\. ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对 象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的 值
>
> 3\. 如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该要 把设置的key，value，也就是Entry对象进⾏回收，但线程池中的线程不会回收，⽽线程对象是通过 强引⽤指向ThreadLocalMap，ThreadLocalMap也是通过强引⽤指向Entry对象，线程不被回收， Entry对象也就不会被回收，从⽽出现内存泄漏，解决办法是，在使⽤了ThreadLocal对象之后，⼿ 动调⽤ThreadLocal的remove⽅法，⼿动清楚Entry对象
>
> 4\. ThreadLocal经典的应⽤场景就是连接管理（⼀个线程持有⼀个连接，该连接对象可以在不同的⽅ 法之间进⾏传递，线程之间不共享同⼀个连接）

30

> ![](media/image1.png){width="6.197916666666667in" height="3.1770833333333335in"}
>
> 并发、并⾏、串⾏之间的区别
>
> 1\. 串⾏在时间上不可能发⽣重叠，前⼀个任务没搞定，下⼀个任务就只能等着 2. 并⾏在时间上是重叠的，两个任务在同⼀时刻互不⼲扰的同时执⾏。
>
> 3\. 并发允许两个任务彼此⼲扰。统⼀时间点、只有⼀个任务运⾏，交替执⾏
>
> 并发的三⼤特性
>
> 原⼦性
>
> 原⼦性是指在⼀个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执⾏完成，要 不都不执⾏。就好⽐转账，从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元， 往账户B加上1000元。2个操作必须全部完成。

Java 复制代码

1 2 3 4 5

private long count = 0;

public void calc() { count++;

}

> 1：将 count 从主存读到⼯作内存中的副本中 ●
>
> 2：+1的运算
>
> ●

31

> 3：将结果写⼊⼯作内存
>
> ●
>
> 4：将⼯作内存的值刷回主存(什么时候刷⼊由操作系统决定，不确定的)
>
> ●
>
> 那程序中原⼦性指的是最⼩的操作单元，⽐如⾃增操作，它本身其实并不是原⼦性操作，分了3步的， 包括读取变量的原始值、进⾏加1操作、写⼊⼯作内存。所以在多线程中，有可能⼀个线程还没⾃增完， 可能才执⾏到第⼆部，另⼀个线程就已经读取了值，导致结果错误。那如果我们能保证⾃增操作是⼀个 原⼦性的操作，那么就能保证其他线程读取到的⼀定是⾃增后的数据。
>
> 关键字：synchronized
>
> 可⻅性
>
> 当多个线程访问同⼀个变量时，⼀个线程修改了这个变量的值，其他线程能够⽴即看得到修改的值。
>
> 若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2⼜使⽤了i，那么这个i值肯定还 是之前的，线程1对变量的修改线程没看到这就是可⻅性问题。

Java 复制代码

1 2 3 4 5 6 7 8

//线程1

boolean stop = false; while(!stop){

doSomething();

}

//线程2

stop = true;

> 如果线程2改变了stop的值，线程1⼀定会停⽌吗？不⼀定。当线程2更改了stop变量的值之后，但是还 没来得及写⼊主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因 此还会⼀直循环下去。
>
> 关键字：volatile、synchronized、final
>
> 有序性
>
> 虚拟机在进⾏代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不⼀定会按 照我们写的代码的顺序来执⾏，有可能将他们重排序。实际上，对于有些代码进⾏重排序之后，虽然对 变量的值没有造成影响，但有可能会出现线程安全问题。

32

1

2

3

4

5

6

7

8

9

10 11 12 13 14

int a = 0;

bool flag = false;

public void write() { a = 2; //1 flag = true; //2 }

public void multiply() { if (flag) { //3 int ret = a \* a;//4

}

}

Java 复制代码

> write⽅法⾥的1和2做了重排序，线程1先对flag赋值为true，随后执⾏到线程2，ret直接计算出结果，再 到线程1，这时候a才赋值为2,很明显迟了⼀步
>
> 关键字：volatile、synchronized
>
> volatile本身就包含了禁⽌指令重排序的语义，⽽synchronized关键字是由"⼀个变量在同⼀时刻只允许 ⼀条线程对其进⾏lock操作"这条规则明确的。
>
> synchronized关键字同时满⾜以上三种特性，但是volatile关键字不满⾜原⼦性。

在某些情况下，volatile的同步机制的性能确实要优于锁(使⽤synchronized关键字或 java.util.concurrent包⾥⾯的锁)，因为volatile的总开销要⽐锁低。

> 我们判断使⽤volatile还是加锁的唯⼀依据就是volatile的语义能否满⾜使⽤的场景(原⼦性)
>
> Java死锁如何避免？
>
> 造成死锁的⼏个原因：
>
> 1\. ⼀个资源每次只能被⼀个线程使⽤
>
> 2\. ⼀个线程在阻塞等待某个资源时，不释放已占有资源
>
> 3\. ⼀个线程已经获得的资源，在未使⽤完之前，不能被强⾏剥夺
>
> 4\. 若⼲线程形成头尾相接的循环等待资源关系

33

> 这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满⾜其中某⼀个条件即可。⽽其中前3 个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。
>
> 在开发过程中：
>
> 1\. 要注意加锁顺序，保证每个线程按同样的顺序进⾏加锁
>
> 2\. 要注意加锁时限，可以针对所设置⼀个超时时间
>
> 3\. 要注意死锁检查，这是⼀种预防机制，确保在第⼀时间发现死锁并进⾏解决
>
> 如何理解volatile关键字
>
> 保证被volatile修饰的共享变量对所有线程总是可⻅的，也就是当⼀个线程修改了⼀个被volatile修饰共 享变量的值，新值总是可以被其他线程⽴即得知。
>
> 如果线程2改变了stop的值，线程1⼀定会停⽌吗？不⼀定。当线程2更改了stop变量的值之后，但是还 没来得及写⼊主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因 此还会⼀直循环下去。

Java 复制代码

1 2 3 4 5 6 7 8

//线程1

boolean stop = false; while(!stop){

doSomething();

}

//线程2

stop = true;

> 禁⽌指令重排序优化

34

1

2

3

4

5

6

7

8

9

10 11 12 13 14

int a = 0;

bool flag = false;

public void write() { a = 2; //1 flag = true; //2 }

public void multiply() { if (flag) { //3 int ret = a \* a;//4

}

}

Java 复制代码

> write⽅法⾥的1和2做了重排序，线程1先对flag赋值为true，随后执⾏到线程2，ret直接计算出结果，再 到线程1，这时候a才赋值为2,很明显迟了⼀步。但是⽤volatile修饰之后就变得不⼀样了：
>
> 1\. 使⽤volatile关键字会强制将修改的值⽴即写⼊主存；
>
> 2\. 使⽤volatile关键字的话，当线程2进⾏修改时，会导致线程1的⼯作内存中缓存变量stop的缓存⾏⽆ 效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存⾏⽆效）；
>
> 3\. 由于线程1的⼯作内存中缓存变量stop的缓存⾏⽆效，所以线程1再次读取变量stop的值时会去主存 读取。

inc++; 其实是两个步骤，先加加，然后再赋值。不是原⼦性操作，所以volatile不能保证线程安全。

> 为什么⽤线程池？解释下线程池参数？
>
> 1、降低资源消耗；提⾼线程利⽤率，降低创建和销毁线程的消耗。
>
> 2、提⾼响应速度；任务来了，直接有线程可⽤可执⾏，⽽不是先创建线程，再执⾏。 3、提⾼线程的可管理性；线程是稀缺资源，使⽤线程池可以统⼀分配调优监控。
>
> corePoolSize 代表核⼼线程数，也就是正常情况下创建⼯作的线程数，这些线程创建后并不会 ●
>
> 消除，⽽是⼀种常驻线程
>
> maxinumPoolSize 代表的是最⼤线程数，它与核⼼线程数相对应，表示最⼤允许被创建的线程 ●

35

> 数，⽐如当前任务较多，将核⼼线程数都⽤完了，还⽆法满⾜需求时，此时就会创建新的线程，但 是线程池内线程总数不会超过最⼤线程数
>
> keepAliveTime 、 unit 表示超出核⼼线程数之外的线程的空闲存活时间，也就是核⼼线程不 ●
>
> 会消除，但是超出核⼼线程数的部分线程如果空闲⼀定的时间则会被消除,我们可以通过 setKeepAliveTime 来设置空闲时间
>
> workQueue ⽤来存放待执⾏的任务，假设我们现在核⼼线程都已被使⽤，还有任务进来则全部 ●
>
> 放⼊队列，直到整个队列被放满但任务还再持续进⼊则会开始创建新的线程
>
> ThreadFactory 实际上是⼀个线程⼯⼚，⽤来⽣产线程执⾏任务。我们可以选择使⽤默认的创 ●
>
> 建⼯⼚，产⽣的线程都在同⼀个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选 择⾃定义线程⼯⼚，⼀般我们会根据业务来制定不同的线程⼯⼚
>
> Handler 任务拒绝策略，有两种情况，第⼀种是当我们调⽤ shutdown 等⽅法关闭线程池后， ●
>
> 这时候即使线程池内部还有没执⾏完的任务正在执⾏，但是由于线程池已经关闭，我们再继续想线 程池提交任务就会遭到拒绝。另⼀种情况就是当达到最⼤线程数，线程池已经没有能⼒继续处理新 提交的任务时，这是也就拒绝
>
> 线程池的底层⼯作原理
>
> 线程池内部是通过队列+线程实现的，当我们利⽤线程池执⾏任务时：
>
> 1\. 如果此时线程池中的线程数量⼩于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建 新的线程来处理被添加的任务。
>
> 2\. 如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放⼊ 缓冲队列。
>
> 3\. 如果此时线程池中的线程数量⼤于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数 量⼩于maximumPoolSize，建新的线程来处理被添加的任务。
>
> 4\. 如果此时线程池中的线程数量⼤于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等 于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。
>
> 5\. 当线程池中的线程数量⼤于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被 终⽌。这样，线程池可以动态的调整池中的线程数
>
> 线程池中阻塞队列的作⽤？为什么是先添加列队⽽不是先创建最 ⼤线程？
>
> 1、⼀般的队列只能保证作为⼀个有限⻓度的缓冲区，如果超出了缓冲⻓度，就⽆法保留当前的任务了， 阻塞队列通过阻塞可以保留住当前想要继续⼊队的任务。

36

> 阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进⼊wait状态，释放cpu资 源。
>
> 阻塞队列⾃带阻塞和唤醒的功能，不需要额外处理，⽆任务执⾏时,线程池利⽤阻塞队列的take⽅法挂 起，从⽽维持核⼼线程的存活、不⾄于⼀直占⽤cpu资源
>
> 2、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。
>
> 就好⽐⼀个企业⾥⾯有10个（core）正式⼯的名额，最多招10个正式⼯，要是任务超过正式⼯⼈数 （task \> core）的情况下，⼯⼚领导（线程池）不是⾸先扩招⼯⼈，还是这10⼈，但是任务可以稍微积 压⼀下，即先放到队列去（代价低）。10个正式⼯慢慢⼲，迟早会⼲完的，要是任务还在继续增加，超 过正式⼯的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时⼯）要是正式⼯加上外包还 是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。
>
> 线程池中线程复⽤原理
>
> 线程池将线程和任务进⾏解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的⼀个 线程必须对应⼀个任务的限制。
>
> 在线程池中，同⼀个线程可以从阻塞队列中不断获取新任务来执⾏，其核⼼原理在于线程池对 Thread 进⾏了封装，并不是每次执⾏任务都会调⽤ Thread.start() 来创建新线程，⽽是让每个线程去执⾏⼀ 个"循环任务"，在这个"循环任务"中不停检查是否有任务需要被执⾏，如果有则直接执⾏，也就是调⽤ 任务中的 run ⽅法，将 run ⽅法当成⼀个普通的⽅法执⾏，通过这种⽅式只使⽤固定的线程就将所有任 务的 run ⽅法串联起来。
>
> ReentrantLock中的公平锁和⾮公平锁的底层实现⾸先不管是公平锁和⾮公平锁，它们的底层实现都会使⽤AQS来进⾏排队，它们的区别在于：线程在使 ⽤lock()⽅法加锁时，如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队， 则当前线程也进⾏排队，如果是⾮公平锁，则不会去检查是否有线程在排队，⽽是直接竞争锁。
>
> 不管是公平锁还是⾮公平锁，⼀旦没竞争到锁，都会进⾏排队，当锁释放时，都是唤醒排在最前⾯的线 程，所以⾮公平锁只是体现在了线程加锁阶段，⽽没有体现在线程被唤醒阶段。

37

> 另外，ReentrantLock是可重⼊锁，不管是公平锁还是⾮公平锁都是可重⼊的。 ![](media/image5.png){width="2.2708333333333335in" height="4.635416666666667in"}![](media/image4.png){width="1.9583333333333333in" height="4.53125in"}
>
> ReentrantLock中tryLock()和lock()⽅法的区别
>
> 1\. tryLock()表示尝试加锁，可能加到，也可能加不到，该⽅法不会阻塞线程，如果加到锁则返回 true，没有加到则返回false
>
> 2\. lock()表示阻塞加锁，线程会阻塞直到加到锁，⽅法也没有返回值
>
> CountDownLatch和Semaphore的区别和底层原理CountDownLatch表示计数器，可以给CountDownLatch设置⼀个数字，⼀个线程调⽤ CountDownLatch的await()将会阻塞，其他线程可以调⽤CountDownLatch的countDown()⽅法来对 CountDownLatch中的数字减⼀，当数字被减成0后，所有await的线程都将被唤醒。 对应的底层原理就是，调⽤await()⽅法的线程会利⽤AQS排队，⼀旦数字被减为0，则会将AQS中 排队的线程依次唤醒。

38

> Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使⽤该信号量，通 过acquire()来获取许可，如果没有许可可⽤则线程阻塞，并通过AQS来排队，可以通过release() ⽅法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第⼀个线程开始依次唤 醒，直到没有空闲许可。
>
> Sychronized的偏向锁、轻量级锁、重量级锁
>
> 1\. 偏向锁：在锁对象的对象头中记录⼀下当前获取到该锁的线程ID，该线程下次如果⼜来获取该锁就 可以直接获取到了
>
> 2\. 轻量级锁：由偏向锁升级⽽来，当⼀个线程获取到锁后，此时这把锁是偏向锁，此时如果有第⼆个 线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻 量级锁底层是通过⾃旋来实现的，并不会阻塞线程
>
> 3\. 如果⾃旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞 4. ⾃旋锁：⾃旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就⽆所谓唤醒线程，阻塞和唤醒 这两个步骤都是需要操作系统去进⾏的，⽐较消耗时间，⾃旋锁是线程通过CAS获取预期的⼀个标 记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程⼀直在运 ⾏中，相对⽽⾔没有使⽤太多的操作系统资源，⽐较轻量。
>
> Sychronized和ReentrantLock的区别
>
> 1\. sychronized是⼀个关键字，ReentrantLock是⼀个类
>
> 2\. sychronized会⾃动的加锁与释放锁，ReentrantLock需要程序员⼿动加锁与释放锁 3. sychronized的底层是JVM层⾯的锁，ReentrantLock是API层⾯的锁
>
> 4\. sychronized是⾮公平锁，ReentrantLock可以选择公平锁或⾮公平锁
>
> 5\. sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识 来标识锁的状态
>
> 6\. sychronized底层有⼀个锁升级的过程
>
> 谈谈你对AQS的理解，AQS如何实现可重⼊锁？
>
> 1\. AQS是⼀个JAVA线程同步的框架。是JDK中很多锁⼯具的核⼼实现框架。
>
> 2\. 在AQS中，维护了⼀个信号量state和⼀个线程组成的双向链表队列。其中，这个线程队列，就是⽤ 来给线程排队的，⽽state就像是⼀个红绿灯，⽤来控制线程排队或者放⾏的。 在不同的场景下， 有不⽤的意义。
>
> 3\. 在可重⼊锁这个场景下，state就⽤来表示加锁的次数。0标识⽆锁，每加⼀次锁，state就加1。释 放锁state就减1。

39

> 开发框架(28)
>
> Spring是什么？
>
> 轻量级的开源的J2EE框架。它是⼀个容器框架，⽤来装javabean（java对象），中间层框架（万能胶） 可以起⼀个连接作⽤，⽐如说把Struts和hibernate粘合在⼀起运⽤，可以让我们的企业开发更快、更简 洁，Spring是⼀个轻量级的控制反转（IoC)和⾯向切⾯（AOP）的容器框架：
>
> 从⼤⼩与开销两⽅⾯⽽⾔Spring都是轻量级的。
>
> ●
>
> 通过控制反转(IoC)的技术达到松耦合的⽬的
>
> ●
>
> 提供了⾯向切⾯编程的丰富⽀持，允许通过分离应⽤的业务逻辑与系统级服务进⾏内聚性的开发 ●
>
> 包含并管理应⽤对象(Bean)的配置和⽣命周期，这个意义上是⼀个容器。
>
> ●
>
> 将简单的组件配置、组合成为复杂的应⽤，这个意义上是⼀个框架。
>
> ●
>
> 谈谈你对AOP的理解
>
> 系统是由许多不同的组件所组成的，每⼀个组件各负责⼀块特定功能。除了实现⾃身核⼼功能之外，这 些组件还经常承担着额外的职责。例如⽇志、事务管理和安全这样的核⼼服务经常融⼊到⾃身具有核⼼ 业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。
>
> 当我们需要为分散的对象引⼊公共⾏为的时候，OOP则显得⽆能为⼒。也就是说，OOP允许你定义从上 到下的关系，但并不适合定义从左到右的关系。例如⽇志功能。
>
> ⽇志代码往往⽔平地散布在所有对象层次中，⽽与它所散布到的对象的核⼼功能毫⽆关系。 在OOP设计中，它导致了⼤量代码的重复，⽽不利于各个模块的重⽤。

AOP：将程序中的交叉业务逻辑（⽐如安全，⽇志，事务等），封装成⼀个切⾯，然后注⼊到⽬标对象 （具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进⾏增强，⽐如对象中的⽅法进⾏增 强，可以在执⾏某个⽅法之前额外的做⼀些事情，在某个⽅法执⾏之后额外的做⼀些事情

> 谈谈你对IOC的理解
>
> 容器概念、控制反转、依赖注⼊

40

> ioc容器：实际上就是个map（key，value），⾥⾯存的是各种对象（在xml⾥配置的bean节点、 \@repository、@service、@controller、@component），在项⽬启动的时候会读取配置⽂件⾥⾯的 bean节点，根据全限定类名使⽤反射创建对象放到map⾥、扫描到打上上述注解的类还是通过反射创建 对象放到map⾥。
>
> 这个时候map⾥就有各种对象了，接下来我们在代码⾥需要⽤到⾥⾯的对象时，再通过DI注⼊ （autowired、resource等注解，xml⾥bean节点内的ref属性，项⽬启动的时候会读取xml节点ref属性 根据id注⼊，也会扫描这些注解，根据类型或id注⼊；id就是对象名）。
>
> 控制反转：
>
> 没有引⼊IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运⾏到某⼀点的时候，⾃⼰必须 主动去创建对象B或者使⽤已经创建的对象B。⽆论是创建还是使⽤对象B，控制权都在⾃⼰⼿上。
>
> 引⼊IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运⾏到需要对象B的时候，IOC容器会 主动创建⼀个对象B注⼊到对象A需要的地⽅。
>
> 通过前后的对⽐，不难看出来：对象A获得依赖对象B的过程,由主动⾏为变为了被动⾏为，控制权颠倒 过来了，这就是"控制反转"这个名称的由来。
>
> 全部对象的控制权全部上缴给"第三⽅"IOC容器，所以，IOC容器成了整个系统的关键核⼼，它起到了 ⼀种类似"粘合剂"的作⽤，把系统中的所有对象粘合在⼀起发挥作⽤，如果没有这个"粘合剂"，对象与 对象之间会彼此失去联系，这就是有⼈把IOC容器⽐喻成"粘合剂"的由来。
>
> 依赖注⼊：
>
> "获得依赖对象的过程被反转了"。控制被反转之后，获得依赖对象的过程由⾃身管理变为了由IOC容器 主动注⼊。依赖注⼊是实现IOC的⽅法，就是由IOC容器在运⾏期间，动态地将某种依赖关系注⼊到对象 之中。
>
> 解释下Spring⽀持的⼏种bean的作⽤域。
>
> singleton：默认，每个容器中只有⼀个bean的实例，单例的模式由BeanFactory⾃身来维护。该 ●
>
> 对象的⽣命周期是与Spring IOC容器⼀致的（但在第⼀次被注⼊时才会创建）。

41

> prototype：为每⼀个bean请求提供⼀个实例。在每次注⼊时都会创建⼀个新的对象 ●
>
> request：bean被定义为在每个HTTP请求中创建⼀个单例对象，也就是说在单个请求中都会复⽤ ●
>
> 这⼀个单例对象。
>
> session：与request范围类似，确保每个session中有⼀个bean的实例，在session过期后，bean ●
>
> 会随之失效。
>
> application：bean被定义为在ServletContext的⽣命周期中复⽤⼀个单例对象。 ●
>
> websocket：bean被定义为在websocket的⽣命周期中复⽤⼀个单例对象。 ●
>
> global-session：全局作⽤域，global-session和Portlet应⽤相关。当你的应⽤部署在Portlet容器 中⼯作时，它包含很多portlet。如果你想要声明让所有的portlet共⽤全局的存储变量的话，那么这 全局变量需要存储在global-session中。全局作⽤域与Servlet中的session作⽤域效果相同。
>
> Spring事务的实现⽅式和原理以及隔离级别？
>
> 在使⽤Spring框架时，可以有两种使⽤事务的⽅式，⼀种是编程式的，⼀种是申明式的， \@Transactional注解就是申明式的。
>
> ⾸先，事务这个概念是数据库层⾯的，Spring只是基于数据库中的事务进⾏了扩展，以及提供了⼀些能 让程序员更加⽅便操作事务的⽅式。
>
> ⽐如我们可以通过在某个⽅法上增加@Transactional注解，就可以开启事务，这个⽅法中所有的sql都 会在⼀个事务中执⾏，统⼀成功或失败。
>
> 在⼀个⽅法上加了@Transactional注解后，Spring会基于这个类⽣成⼀个代理对象，会将这个代理对象 作为bean，当在使⽤这个代理对象的⽅法时，如果这个⽅法上存在@Transactional注解，那么代理逻辑 会先把事务的⾃动提交设置为false，然后再去执⾏原本的业务逻辑⽅法，如果执⾏业务逻辑⽅法没有出 现异常，那么代理逻辑中就会将事务进⾏提交，如果执⾏业务逻辑⽅法出现了异常，那么则会将事务进 ⾏回滚。
>
> 当然，针对哪些异常回滚事务是可以配置的，可以利⽤@Transactional注解中的rollbackFor属性进⾏配 置，默认情况下会对RuntimeException和Error进⾏回滚。
>
> spring事务隔离级别就是数据库的隔离级别：外加⼀个默认级别
>
> read uncommitted（未提交读） ●

42

> read committed（提交读、不可重复读）
>
> ●
>
> repeatable read（可重复读）
>
> ●
>
> serializable（可串⾏化）
>
> ●

Plain Text 复制代码

> 1
>
> 数据库的配置隔离级别是Read Commited,⽽Spring配置的隔离级别是Repeatable Read，请问这时 隔离级别是以哪⼀个为准？
>
> 2
>
> 以Spring配置的为准，如果spring设置的隔离级别数据库不⽀持，效果取决于数据库
>
> Spring事务传播机制
>
> 多个事务⽅法相互调⽤时，事务如何在这些⽅法间传播，⽅法A是⼀个事务的⽅法，⽅法A执⾏过程中调 ⽤了⽅法B，那么⽅法B有⽆事务以及⽅法B对事务的要求不同都会对⽅法A的事务具体执⾏造成影响， 同时⽅法A的事务对⽅法B的事务执⾏也有影响，这种影响具体是什么就由两个⽅法所定义的事务传播类 型所决定。
>
> 1\. REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则⾃⼰新建⼀个事务，如果当前存 在事务，则加⼊这个事务
>
> 2\. SUPPORTS：当前存在事务，则加⼊当前事务，如果当前没有事务，就以⾮事务⽅法执⾏ 3. MANDATORY：当前存在事务，则加⼊当前事务，如果当前事务不存在，则抛出异常。 4. REQUIRES_NEW：创建⼀个新事务，如果存在当前事务，则挂起该事务。 5. NOT_SUPPORTED：以⾮事务⽅式执⾏,如果当前存在事务，则挂起当前事务 6. NEVER：不使⽤事务，如果当前事务存在，则抛出异常
>
> 7\. NESTED：如果当前事务存在，则在嵌套事务中执⾏，否则REQUIRED的操作⼀样（开启⼀个事 务）
>
> Spring事务什么时候会失效?
>
> spring事务的原理是AOP，进⾏了切⾯增强，那么失效的根本原因是这个AOP不起作⽤了！常⻅情况有 如下⼏种
>
> 1、发⽣⾃调⽤，类⾥⾯使⽤this调⽤本类的⽅法（this通常省略），此时这个this对象不是代理类，⽽是 UserService对象本身！
>
> 解决⽅法很简单，让那个this变成UserService的代理类即可！

43

> 2、⽅法不是public的：@Transactional 只能⽤于 public 的⽅法上，否则事务不会失效，如果要⽤在⾮ public ⽅法上，可以开启 AspectJ 代理模式。
>
> 3、数据库不⽀持事务
>
> 4、没有被spring管理
>
> 5、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)
>
> 什么是bean的⾃动装配，有哪些⽅式？
>
> 开启⾃动装配，只需要在xml配置⽂件中定义"autowire"属性。

Plain Text 复制代码

> 1 \<bean id=\"cutomer\" class=\"com.xxx.xxx.Customer\" autowire=\"\" /\> autowire属性有五种装配的⽅式：

●

Plain Text 复制代码

no -- 缺省情况下，⾃动配置是通过"ref"属性⼿动设定 。

1

2

●

Plain Text 复制代码

⼿动装配：以value或ref的⽅式明确指定属性值都是⼿动装配。 需要通过'ref'属性来连接bean。

byName-根据bean的属性名称进⾏⾃动装配。

> 1
>
> Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter⽅法进⾏⾃动装 配。
>
> 2
>
> \<bean id=\"cutomer\" class=\"com.xxx.xxx.Cutomer\" autowire=\"byName\"/\> 3
>
> \<bean id=\"person\" class=\"com.xxx.xxx.Person\"/\>
>
> byType-根据bean的类型进⾏⾃动装配。
>
> ●

Plain Text 复制代码

> 1
>
> Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter⽅法进⾏⾃动装配。 2
>
> \<bean id=\"cutomer\" class=\"com.xxx.xxx.Cutomer\" autowire=\"byType\"/\> 3
>
> \<bean id=\"person\" class=\"com.xxx.xxx.Person\"/\>
>
> constructor-类似byType，不过是应⽤于构造器的参数。如果⼀个bean与构造器参数的类型形 ●
>
> 同，则进⾏⾃动装配，否则导致异常。

44

Plain Text 复制代码

> 1
>
> Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造⽅法进⾏⾃动装 配。
>
> 2
>
> \<bean id=\"cutomer\" class=\"com.xxx.xxx.Cutomer\" autowire=\"construtor\"/\> 3
>
> \<bean id=\"person\" class=\"com.xxx.xxx.Person\"/\>
>
> autodetect-如果有默认的构造器，则通过constructor⽅式进⾏⾃动装配，否则使⽤byType⽅式 ●

进⾏⾃动装配。

Plain Text 复制代码

> 1 如果有默认的构造器，则通过constructor⽅式进⾏⾃动装配，否则使⽤byType⽅式进⾏⾃动装配。@Autowired⾃动装配bean，可以在字段、setter⽅法、构造函数上使⽤。
>
> Spring中的Bean创建的⽣命周期有哪些步骤
>
> Spring中⼀个Bean的创建⼤概分为以下⼏个步骤：
>
> 1\. 推断构造⽅法
>
> 2\. 实例化
>
> 3\. 填充属性，也就是依赖注⼊
>
> 4\. 处理Aware回调
>
> 5\. 初始化前，处理@PostConstruct注解
>
> 6\. 初始化，处理InitializingBean接⼝
>
> 7\. 初始化后，进⾏AOP
>
> 当然其实真正的步骤更加细致，可以看下⾯的流程图

45

![](media/image7.png){width="7.145833333333333in" height="3.4583333333333335in"}

> Spring中Bean是线程安全的吗
>
> Spring本身并没有针对Bean做线程安全的处理，所以：
>
> 1\. 如果Bean是⽆状态的，那么Bean则是线程安全的
>
> 2\. 如果Bean是有状态的，那么Bean则不是线程安全的
>
> 另外，Bean是不是线程安全，跟Bean的作⽤域没有关系，Bean的作⽤域只是表示Bean的⽣命周期范 围，对于任何⽣命周期的Bean都是⼀个对象，这个对象是不是线程安全的，还是得看这个Bean对象本 身。
>
> ApplicationContext和BeanFactory有什么区别 BeanFactory是Spring中⾮常核⼼的组件，表示Bean⼯⼚，可以⽣成Bean，维护Bean，⽽ ApplicationContext继承了BeanFactory，所以ApplicationContext拥有BeanFactory所有的特点，也 是⼀个Bean⼯⼚，但是ApplicationContext除开继承了BeanFactory之外，还继承了诸如 EnvironmentCapable、MessageSource、ApplicationEventPublisher等接⼝，从⽽ ApplicationContext还有获取系统环境变量、国际化、事件发布等功能，这是BeanFactory所不具备的
>
> Spring中的事务是如何实现的

46

> 1\. Spring事务底层是基于数据库事务和AOP机制的
>
> 2\. ⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean 3. 当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解 4. 如果加了，那么则利⽤事务管理器创建⼀个数据库连接
>
> 5\. 并且修改数据库连接的autocommit属性为false，禁⽌此连接的⾃动提交，这是实现Spring事务⾮ 常重要的⼀步
>
> 6\. 然后执⾏当前⽅法，⽅法中会执⾏sql
>
> 7\. 执⾏完当前⽅法后，如果没有出现异常就直接提交事务
>
> 8\. 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务 9. Spring事务的隔离级别对应的就是数据库的隔离级别
>
> 10\. Spring事务的传播机制是Spring事务⾃⼰实现的，也是Spring事务中最复杂的 11. Spring事务的传播机制是基于数据库连接来做的，⼀个数据库连接⼀个事务，如果传播机制配置为 需要新开⼀个事务，那么实际上就是先建⽴⼀个数据库连接，在此新数据库连接上执⾏sql

![](media/image6.png){width="7.145833333333333in" height="2.4479166666666665in"}

> Spring中什么时候@Transactional会失效
>
> 因为Spring事务是基于代理来实现的，所以某个加了@Transactional的⽅法只有是被代理对象调⽤时， 那么这个注解才会⽣效，所以如果是被代理对象来调⽤这个⽅法，那么@Transactional是不会失效的。
>
> 同时如果某个⽅法是private的，那么@Transactional也会失效，因为底层cglib是基于⽗⼦类来实现 的，⼦类是不能重载⽗类的private⽅法的，所以⽆法很好的利⽤代理，也会导致@Transactianal失效
>
> Spring容器启动流程是怎样的
>
> 1\. 在创建Spring容器，也就是启动Spring时：
>
> 2\. ⾸先会进⾏扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中

47

3\. 然后筛选出⾮懒加载的单例BeanDefinition进⾏创建Bean，对于多例Bean不需要在启动过程中去 进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建

4\. 利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推断 构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始化 后这⼀步骤中

5\. 单例Bean创建完了之后，Spring会发布⼀个容器启动事件

6\. Spring启动结束

7\. 在源码中会更复杂，⽐如源码中会提供⼀些模板⽅法，让⼦类来实现，⽐如源码中还涉及到⼀些 BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过 BenaFactoryPostProcessor来实现的，依赖注⼊就是通过BeanPostProcessor来实现的 8. 在Spring启动过程中还会去处理@Import等注解

![](media/image3.png){width="7.145833333333333in" height="6.645833333333333in"}48

> Spring⽤到了哪些设计模式
>
> ![](media/image8.png){width="6.53125in" height="4.166666666666667in"}
>
> Spring Boot、Spring MVC 和 Spring 有什么区别
>
> spring是⼀个IOC容器，⽤来管理Bean，使⽤依赖注⼊实现控制反转，可以很⽅便的整合各种框架，提 供AOP机制弥补OOP的代码重复问题、更⽅便将不同类不同⽅法中的共同处理抽取成切⾯、⾃动注⼊给 ⽅法执⾏，⽐如⽇志、异常等
>
> springmvc是spring对web框架的⼀个解决⽅案，提供了⼀个总的前端控制器Servlet，⽤来接收请求， 然后定义了⼀套路由策略（url到handle的映射）及适配执⾏handle，将handle结果使⽤视图解析技术⽣ 成视图展现给前端
>
> springboot是spring提供的⼀个快速开发⼯具包，让程序员能更⽅便、更快速的开发spring+springmvc 应⽤，简化了配置（约定了默认配置），整合了⼀系列的解决⽅案（starter机制）、redis、 mongodb、es，可以开箱即⽤

49

> Spring MVC ⼯作流程
>
> 1）⽤户发送请求⾄前端控制器 DispatcherServlet。
>
> 2）DispatcherServlet 收到请求调⽤ HandlerMapping 处理器映射器。
>
> 3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进⾏查找)，⽣成处理器及处理器拦截器 (如果有则⽣成)⼀并返回给 DispatcherServlet。
>
> 4）DispatcherServlet 调⽤ HandlerAdapter 处理器适配器。
>
> 5）HandlerAdapter 经过适配调⽤具体的处理器(Controller，也叫后端控制器) 6）Controller 执⾏完成返回 ModelAndView。
>
> 7）HandlerAdapter 将 controller 执⾏结果 ModelAndView 返回给 DispatcherServlet。8） DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。
>
> 9）ViewReslover 解析后返回具体 View。
>
> 10）DispatcherServlet 根据 View 进⾏渲染视图（即将模型数据填充⾄视图中）。 11）DispatcherServlet 响应⽤户。
>
> Spring MVC的主要组件？
>
> Handler：也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可 以是类，也可以是⽅法。在Controller层中@RequestMapping标注的所有⽅法都可以看成是⼀个 Handler，只要可以实际处理请求就可以是Handler
>
> 1、HandlerMapping
>
> initHandlerMappings(context)，处理器映射器，根据⽤户请求的资源uri来查找Handler的。在 SpringMVC中会有很多请求，每个请求都需要⼀个Handler处理，具体接收到⼀个请求之后使⽤哪个 Handler进⾏，这就是HandlerMapping需要做的事。

50

> 2、HandlerAdapter
>
> initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理 请求就ok，但是Servlet需要的处理⽅法的结构却是固定的，都是以request和response为参数的⽅法。 如何让固定的Servlet处理⽅法调⽤灵活的Handler来进⾏处理呢？这就是HandlerAdapter要做的事情。 Handler是⽤来⼲活的⼯具；HandlerMapping⽤于根据需要⼲的活找到相应的⼯具；HandlerAdapter
>
> 是使⽤⼯具⼲活的⼈。
>
> 3、HandlerExceptionResolver
>
> initHandlerExceptionResolvers(context)， 其它组件都是⽤来⼲活的。在⼲活的过程中难免会出现问 题，出问题后怎么办呢？这就需要有⼀个专⻔的⻆⾊对异常情况进⾏处理，在SpringMVC中就是 HandlerExceptionResolver。具体来说，此组件的作⽤是根据异常设置ModelAndView，之后再交给 render⽅法进⾏渲染。
>
> 4、ViewResolver
>
> initViewResolvers(context)，ViewResolver⽤来将String类型的视图名和Locale解析为View类型的视 图。View是⽤来渲染⻚⾯的，也就是将程序返回的参数填⼊模板⾥，⽣成html（也可能是其它类型）⽂ 件。这⾥就有两个关键问题：使⽤哪个模板？⽤什么技术（规则）填⼊参数？这其实是ViewResolver主 要要做的⼯作，ViewResolver需要找到渲染所⽤的模板和所⽤的技术（也就是视图的类型）进⾏渲染， 具体的渲染过程则交由不同的视图⾃⼰完成。
>
> 5、RequestToViewNameTranslator
>
> initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的 Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如 何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。 RequestToViewNameTranslator在Spring MVC容器⾥只可以配置⼀个，所以所有request到 ViewName的转换规则都要在⼀个Translator⾥⾯全部实现。
>
> 6、LocaleResolver
>
> initLocaleResolver(context)， 解析视图需要两个参数：⼀是视图名，另⼀个是Locale。视图名是处理 器返回的，Locale是从哪⾥来的？这就是LocaleResolver要做的事情。LocaleResolver⽤于从request 解析出Locale，Locale就是zh-cn之类，表示⼀个区域，有了这个就可以对不同区域的⽤户显示不同的 结果。SpringMVC主要有两个地⽅⽤到了Locale：⼀是ViewResolver视图解析的时候；⼆是⽤到国际 化资源或者主题的时候。

51

> 7、ThemeResolver
>
> initThemeResolver(context)，⽤于解析主题。SpringMVC中⼀个主题对应⼀个properties⽂件，⾥⾯ 存放着跟当前主题相关的所有资源、如图⽚、css样式等。SpringMVC的主题也⽀持国际化，同⼀个主 题不同区域也可以显示不同的⻛格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource 和Theme。主题是通过⼀系列资源来具体体现的，要得到⼀个主题的资源，⾸先要得到资源的名称，这
>
> 是ThemeResolver的⼯作。然后通过主题名称找到对应的主题（可以理解为⼀个配置）⽂件，这是 ThemeSource的⼯作。最后从主题中获取资源就可以了。
>
> 8、MultipartResolver
>
> initMultipartResolver(context)，⽤于处理上传请求。处理⽅法是将普通的request包装成 MultipartHttpServletRequest，后者可以直接调⽤getFile⽅法获取File，如果上传多个⽂件，还可以调 ⽤getFileMap得到FileName-\>File结构的Map。此组件中⼀共有三个⽅法，作⽤分别是判断是不是上传 请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产⽣的临时资源。
>
> 9、FlashMapManager
>
> initFlashMapManager(context)，⽤来管理FlashMap的，FlashMap主要⽤在redirect中传递参数。
>
> Spring Boot ⾃动配置原理？
>
> \@Import + \@Configuration + Spring spi
>
> ⾃动配置类由各个starter提供，使⽤@Configuration + \@Bean定义配置类，放到META INF/spring.factories下
>
> 使⽤Spring spi扫描META-INF/spring.factories下的配置类
>
> 使⽤@Import导⼊⾃动配置类
>
> 如何理解 Spring Boot 中的 Starter
>
> 使⽤spring + springmvc使⽤，如果需要引⼊mybatis等框架，需要到xml中定义mybatis需要的bean
>
> starter就是定义⼀个starter的jar包，写⼀个@Configuration配置类、将这些bean定义在⾥⾯，然后在 starter包的META-INF/spring.factories中写⼊该配置类，springboot会按照约定来加载该配置类

52

> 开发⼈员只需要将相应的starter包依赖进应⽤，进⾏相应的属性配置（使⽤默认配置时，不需要配 置），就可以直接进⾏代码开发，使⽤对应的功能了，⽐如mybatis-spring-boot\--starter，spring boot-starter-redis
>
> 什么是嵌⼊式服务器？为什么要使⽤嵌⼊式服务器? 节省了下载安装tomcat，应⽤也不需要再打war包，然后放到webapp⽬录下再运⾏ 只需要⼀个安装了 Java 的虚拟机，就可以直接在上⾯部署应⽤程序了
>
> springboot已经内置了tomcat.jar，运⾏main⽅法时会去启动tomcat，并利⽤tomcat的spi机制加载 springmvc
>
> Spring Boot中常⽤注解及其底层实现
>
> 1\. \@SpringBootApplication注解：这个注解标识了⼀个SpringBoot⼯程，它实际上是另外三个注解 的组合，这三个注解是：
>
> a\. \@SpringBootConfiguration：这个注解实际就是⼀个@Configuration，表示启动类也是⼀个 配置类
>
> b\. \@EnableAutoConfiguration：向Spring容器中导⼊了⼀个Selector，⽤来加载ClassPath下 SpringFactories中所定义的⾃动配置类，将这些⾃动加载为配置Bean
>
> c\. \@ComponentScan：标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫 描的路径是启动类所在的当前⽬录
>
> 2\. \@Bean注解：⽤来定义Bean，类似于XML中的\<bean\>标签，Spring在启动时，会对加了@Bean注 解的⽅法进⾏解析，将⽅法的名字做为beanName，并通过执⾏⽅法得到bean对象 3. \@Controller、@Service、@ResponseBody、@Autowired都可以说
>
> Spring Boot是如何启动Tomcat的
>
> 1\. ⾸先，SpringBoot在启动时会先创建⼀个Spring容器
>
> 2\. 在创建Spring容器过程中，会利⽤@ConditionalOnClass技术来判断当前classpath中是否存在 Tomcat依赖，如果存在则会⽣成⼀个启动Tomcat的Bean
>
> 3\. Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端⼝等，然后 启动Tomcat

53

> Spring Boot中配置⽂件的加载顺序是怎样的？
>
> 优先级从⾼到低，⾼优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。 1. 命令⾏参数。所有的配置都可以在命令⾏上进⾏指定；
>
> 2\. Java系统属性（System.getProperties()）；
>
> 3\. 操作系统环境变量 ；
>
> 4\. jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置⽂件 5. jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置⽂件 再来加 载不带profile
>
> 6\. jar包外部的application.properties或application.yml(不带spring.profile)配置⽂件 7. jar包内部的application.properties或application.yml(不带spring.profile)配置⽂件 8. \@Configuration注解类上的@PropertySource
>
> Mybatis的优缺点
>
> 优点：
>
> 1\. 基于 SQL 语句编程，相当灵活，不会对应⽤程序或者数据库的现有设计造成任何影响，SQL 写在 XML ⾥，解除 sql 与程序代码的耦合，便于统⼀管理；提供 XML 标签， ⽀持编写动态 SQL 语 句， 并可重⽤。
>
> 2\. 与 JDBC 相⽐，减少了 50%以上的代码量，消除了 JDBC ⼤量冗余的代码，不需要⼿动开关连 接；
>
> 3\. 很好的与各种数据库兼容（ 因为 MyBatis 使⽤ JDBC 来连接数据库，所以只要JDBC ⽀持的数据 库 MyBatis 都⽀持）。
>
> 4\. 能够与 Spring 很好的集成；
>
> 5\. 提供映射标签， ⽀持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， ⽀持对象关 系组件维护。
>
> 缺点：
>
> 1\. SQL 语句的编写⼯作量较⼤， 尤其当字段多、关联表多时， 对开发⼈员编写SQL 语句的功底有⼀ 定要求。
>
> 2\. SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。
>
> MyBatis 与Hibernate 有哪些不同？

54

> SQL 和 ORM 的争论，永远都不会终⽌
>
> 开发速度的对⽐：
>
> Hibernate的真正掌握要⽐Mybatis难些。Mybatis框架相对简单很容易上⼿，但也相对简陋些。 ⽐起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项⽬需求去考虑究竟哪⼀个更适合 项⽬开发，⽐如：⼀个项⽬中⽤到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率 就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了⼤量的时间， 但是对于⼀个⼤型项⽬，复杂语句较多，这样再去选择hibernate就不是⼀个太好的选择，选择mybatis 就会加快许多，⽽且语句的管理也⽐较⽅便。
>
> 开发⼯作量的对⽐：
>
> Hibernate和MyBatis都有相应的代码⽣成⼯具。可以⽣成简单基本的DAO层⽅法。针对⾼级查询， Mybatis需要⼿动编写SQL语句，以及ResultMap。⽽Hibernate有良好的映射机制，开发者⽆需关⼼ SQL的⽣成与结果映射，可以更专注于业务流程
>
> sql优化⽅⾯：
>
> Hibernate的查询会将表中的所有字段查询出来，这⼀点会有性能消耗。Hibernate也可以⾃⼰写SQL来 指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。⽽Mybatis的SQL是⼿动编写的，所以 可以按需求指定查询的字段。
>
> Hibernate HQL语句的调优需要将SQL打印出来，⽽Hibernate的SQL被很多⼈嫌弃因为太丑了。 MyBatis的SQL是⾃⼰⼿动写的所以调整⽅便。但Hibernate具有⾃⼰的⽇志统计。Mybatis本身不带⽇ 志统计，使⽤Log4j进⾏⽇志记录。
>
> 对象管理的对⽐：
>
> Hibernate 是完整的对象/关系映射解决⽅案，它提供了对象状态管理（state management）的功能， 使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常⻅的 JDBC/SQL 持久层⽅案中需 要管理 SQL 语句，Hibernate采⽤了更⾃然的⾯向对象的视⻆来持久化 Java 应⽤中的数据。 换句话说，使⽤ Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执⾏。 这部分细节已经由 Hibernate 掌管妥当，只有开发者在进⾏系统性能调优的时候才需要进⾏了解。⽽ MyBatis在这⼀块没有⽂档说明，⽤户需要对对象⾃⼰进⾏详细的管理。
>
> 缓存机制对⽐：
>
> 相同点：都可以实现⾃⼰的缓存或使⽤其他第三⽅缓存⽅案，创建适配器来完全覆盖缓存⾏为。

55

> 不同点：Hibernate的⼆级缓存配置在SessionFactory⽣成的配置⽂件中进⾏详细配置，然后再在具体 的表-对象映射中配置是哪种缓存。
>
> MyBatis的⼆级缓存配置都是在每个具体的表-对象映射中进⾏详细配置，这样针对不同的表可以⾃定义 不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实 现。
>
> 两者⽐较：因为Hibernate对查询对象有着良好的管理机制，⽤户⽆需关⼼SQL。所以在使⽤⼆级缓存 时如果出现脏数据，系统会报出错误并提示。
>
> ⽽MyBatis在这⼀⽅⾯，使⽤⼆级缓存时需要特别⼩⼼。如果不能完全确定数据更新操作的波及范围， 避免Cache的盲⽬使⽤。否则，脏数据的出现会给系统的正常运⾏带来很⼤的隐患。
>
> Hibernate功能强⼤，数据库⽆关性好，O/R映射能⼒强，如果你对Hibernate相当精通，⽽且对 Hibernate进⾏了适当的封装，那么你的项⽬整个持久层代码会相当简单，需要写的代码很少，开发速 度很快，⾮常爽。
>
> Hibernate的缺点就是学习⻔槛不低，要精通⻔槛更⾼，⽽且怎么设计O/R映射，在性能和对象模型之间 如何权衡取得平衡，以及怎样⽤好Hibernate⽅⾯需要你的经验和能⼒都很强才⾏。
>
> iBATIS⼊⻔简单，即学即⽤，提供了数据库查询的⾃动对象绑定功能，⽽且延续了很好的SQL使⽤经 验，对于没有那么⾼的对象模型要求的项⽬来说，相当完美。
>
> iBATIS的缺点就是框架还是⽐较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库 查询实际还是要⾃⼰写的，⼯作量也⽐较⼤，⽽且不太容易适应快速数据库修改。
>
> #{}和\${}的区别是什么？
>
> #{}是预编译处理、是占位符， \${}是字符串替换、是拼接符。
>
> Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调⽤ PreparedStatement 来赋值；
>
> 时，就是把
>
> Mybatis 在处理 {}替换成变量的值，调⽤ Statement 来赋值；

56

> #{} 的变量替换是在DBMS 中、变量替换后，#{} 对应的变量⾃动加上单引号，{} 的变量替换是在 DBMS 外、变量替换后，{} 对应的变量不会加上单引号
>
> 使⽤#{}可以有效的防⽌ SQL 注⼊， 提⾼系统安全性。
>
> 简述 Mybatis 的插件运⾏原理，如何编写⼀个插件。
>
> Mybatis 只⽀持针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种 接⼝的插件， Mybatis 使⽤ JDK 的动态代理， 为需要拦截的接⼝⽣成代理对象以实现接⼝⽅法拦截功 能， 每当执⾏这 4 种接⼝对象的⽅法时，就会进⼊拦截⽅法，具体就是 InvocationHandler 的 invoke() ⽅法， 拦截那些你指定需要拦截的⽅法。
>
> 编写插件： 实现 Mybatis 的 Interceptor 接⼝并复写 intercept()⽅法， 然后在给插件编写注解， 指定 要拦截哪⼀个接⼝的哪些⽅法即可， 在配置⽂件中配置编写的插件。

Java 复制代码

> 1
>
> \@Intercepts({@Signature(type = StatementHandler.class, method = \"query\", args = {Statement.class, ResultHandler.class}),
>
> 2
>
> \@Signature(type = StatementHandler.class, method = \"update\", args = {Statement.class}),
>
> 3
>
> \@Signature(type = StatementHandler.class, method = \"batch\", args = { Statement.class })})
>
> 4
>
> \@Component
>
> 5
>
> 6
>
> 7
>
> invocation.proceed()执⾏具体的业务逻辑
>
> Mysql(20)
>
> 索引的基本原理
>
> 索引⽤来快速地寻找那些具有特定值的记录。如果没有索引，⼀般来说执⾏查询时遍历整张表。 索引的原理：就是把⽆序的数据变成有序的查询

57

> 1\. 把创建了索引的列的内容进⾏排序
>
> 2\. 对排序结果⽣成倒排表
>
> 3\. 在倒排表内容上拼上数据地址链
>
> 4\. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从⽽拿到具体数据
>
> Mysql聚簇和⾮聚簇索引的区别
>
> 都是B+树的数据结构
>
> 聚簇索引：将数据存储与索引放到了⼀块、并且是按照⼀定的顺序组织的，找到索引也就找到了数 ●
>
> 据，数据的物理存放顺序与索引顺序是⼀致的，即：只要索引是相邻的，那么对应的数据⼀定也是 相邻地存放在磁盘上的
>
> ⾮聚簇索引：叶⼦节点不存储数据、存储的是数据⾏地址，也就是说根据索引查找到数据⾏的位置 ●
>
> 再取磁盘查找数据，这个就有点类似⼀本树的⽬录，⽐如我们要找第三章第⼀节，那我们先在这个 ⽬录⾥⾯找，找到对应的⻚码后再去对应的⻚码看⽂章。
>
> 优势：1、查询通过聚簇索引可以直接获取数据，相⽐⾮聚簇索引需要第⼆次查询（⾮覆盖索引的情况 下）效率要⾼
>
> 2、聚簇索引对于范围查询的效率很⾼，因为其数据是按照⼤⼩排列的
>
> 3、聚簇索引适合⽤在排序的场合，⾮聚簇索引不适合
>
> 劣势：
>
> 1、维护索引很昂贵，特别是插⼊新⾏或者主键被更新导⾄要分⻚(page split)的时候。建议在⼤量插⼊ 新⾏后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的⾏数据可能造成碎 ⽚。使⽤独享表空间可以弱化碎⽚
>
> 2、表因为使⽤UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有⽐全表扫⾯ 更慢，所以建议使⽤int的auto_increment作为主键
>
> 3、如果主键⽐较⼤的话，那辅助索引将会变的更⼤，因为辅助索引的叶⼦存储的是主键值；过⻓的主 键值，会导致⾮叶⼦节点占⽤占⽤更多的物理空间
>
> InnoDB中⼀定有主键，主键⼀定是聚簇索引，不⼿动设置、则会使⽤unique索引，没有unique索引， 则会使⽤数据库内部的⼀个⾏的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，

58

> 辅助索引访问数据总是需要⼆次查找，⾮聚簇索引都是辅助索引，像复合索引、前缀索引、唯⼀索引， 辅助索引叶⼦节点存储的不再是⾏的物理位置，⽽是主键值
>
> MyISM使⽤的是⾮聚簇索引，没有聚簇索引，⾮聚簇索引的两棵B+树看上去没什么不同，节点的结构完 全⼀致只是存储的内容不同⽽已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。 表数据存储在独⽴的地⽅，这两颗B+树的叶⼦节点都使⽤⼀个地址指向真正的表数据，对于表数据来 说，这两个键没有任何差别。由于索引树是独⽴的，通过辅助键检索⽆需访问主键的索引树。
>
> 如果涉及到⼤数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占 空间⼩，这些操作是需要在内存中完成的。
>
> Mysql索引的数据结构，各⾃优劣
>
> 索引的数据结构和具体存储引擎的实现有关，在MySQL中使⽤较多的索引有Hash索引，B+树索引等， InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因 此在绝⼤多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余⼤部分场景，建议 选择BTree索引。
>
> B+树：B+树是⼀个平衡的多叉树，从根节点到每个叶⼦节点的⾼度差值不超过1，⽽且同层级的节点间 有指针相互链接。在B+树上的常规检索，从根节点到叶⼦节点的搜索效率基本相当，不会出现⼤幅波 动，⽽且基于索引的顺序扫描时，也可以利⽤双向指针快速左右移动，效率⾮常⾼。因此，B+树索引被 ⼴泛应⽤于数据库、⽂件系统等场景。
>
> 哈希索引：哈希索引就是采⽤⼀定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样 从根节点到叶⼦节点逐级查找，只需⼀次哈希算法即可⽴刻定位到相应的位置，速度⾮常快
>
> 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过⼀次算法即可找到相应的键值；前提 是键值都是唯⼀的。如果键值不是唯⼀的，就需要先找到该键所在位置，然后再根据链表往后扫描，直 到找到相应的数据；
>
> 如果是范围查询检索，这时候哈希索引就毫⽆⽤武之地了，因为原先是有序的键值，经过哈希算法后， 有可能变成不连续的了，就没办法再利⽤索引完成范围查询检索；

59

> 哈希索引也没办法利⽤索引完成排序，以及like 'xxx%' 这样的部分模糊查询（这种部分模糊查询，其实 本质上也是范围查询）；
>
> 哈希索引也不⽀持多列联合索引的最左匹配规则；
>
> B+树索引的关键字检索效率⽐较平均，不像B树那样波动幅度⼤，在有⼤量重复键值情况下，哈希索引 的效率也是极低的，因为存在哈希碰撞问题。
>
> 索引设计的原则？
>
> 查询更快、占⽤空间更⼩
>
> 1\. 适合索引的列是出现在where⼦句中的列，或者连接⼦句中指定的列
>
> 2\. 基数较⼩的表，索引效果较差，没有必要在此列建⽴索引
>
> 3\. 使⽤短索引，如果对⻓字符串列进⾏索引，应该指定⼀个前缀⻓度，这样能够节省⼤量索引空间， 如果搜索词超过索引前缀⻓度，则使⽤索引排除不匹配的⾏，然后检查其余⾏是否可能匹配。 4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进 ⾏更新甚⾄重构，索引列越多，这个时间就会越⻓。所以只保持需要的索引有利于查询即可。 5. 定义有外键的数据列⼀定要建⽴索引。
>
> 6\. 更新频繁字段不适合创建索引
>
> 7\. 若是不能有效区分数据的列不适合做索引列(如性别，男⼥未知，最多也就三种，区分度实在太低) 8. 尽量的扩展索引，不要新建索引。⽐如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修 改原来的索引即可。
>
> 9\. 对于那些查询中很少涉及的列，重复值⽐较多的列不要建⽴索引。
>
> 10\. 对于定义为text、image和bit的数据类型的列不要建⽴索引。
>
> InnoDB存储引擎的锁的算法
>
> Record lock：单个⾏记录上的锁 ●

60

> Gap lock：间隙锁，锁定⼀个范围，不包括记录本身
>
> ●
>
> Next-key lock：record+gap 锁定⼀个范围，包含记录本身
>
> ●
>
> 相关知识点：
>
> 1\. innodb对于⾏的查询使⽤next-key lock
>
> 2\. Next-locking keying为了解决Phantom Problem幻读问题
>
> 3\. 当查询的索引含有唯⼀属性时，将next-key lock降级为record key
>
> 4\. Gap锁设计的⽬的是为了阻⽌多个事务将记录插⼊到同⼀范围内，⽽这会导致幻读问题的产⽣ 5. 有两种⽅式显式关闭gap锁：（除了外键约束和唯⼀性检查外，其余情况仅使⽤record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1
>
> 关⼼过业务系统⾥⾯的sql耗时吗？统计过慢查询吗？对慢查询都 怎么优化过？
>
> 在业务系统中，除了使⽤主键进⾏的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运 维在做，会定期将业务中的慢查询反馈给我们。
>
> 慢查询的优化⾸先要搞明⽩慢的原因是什么？是查询条件没有命中索引？是load了不需要的数据列？还 是数据量太⼤？
>
> 所以优化也是针对这三个⽅向来的，
>
> ⾸先分析语句，看看是否load了额外的数据，可能是查询了多余的⾏并且抛弃掉了，可能是加载了 ●
>
> 许多结果中并不需要的列，对语句进⾏分析以及重写。
>
> 分析语句的执⾏计划，然后获得其使⽤索引的情况，之后修改语句或者修改索引，使得语句可以尽 ●
>
> 可能的命中索引。
>
> 如果对语句的优化已经⽆法进⾏，可以考虑表中的数据量是否太⼤，如果是的话可以进⾏横向或者 ●
>
> 纵向的分表。
>
> 事务的基本特性和隔离级别
>
> 事务基本特性ACID分别是：

61

> 原⼦性指的是⼀个事务中的操作要么全部成功，要么全部失败。
>
> ⼀致性指的是数据库总是从⼀个⼀致性的状态转换到另外⼀个⼀致性的状态。⽐如A转账给B100块钱， 假设A只有90块，⽀付之前我们数据库⾥的数据都是符合约束的,但是如果事务执⾏成功了,我们的数据库 数据就破坏约束了,因此事务不能成功,这⾥我们说事务提供了⼀致性的保证
>
> 隔离性指的是⼀个事务的修改在最终提交前，对其他事务是不可⻅的。
>
> 持久性指的是⼀旦事务提交，所做的修改就会永久保存到数据库中。
>
> 隔离性有4个隔离级别，分别是：
>
> read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。 ●
>
> ⽤户本来应该读取到id=1的⽤户age应该是10，结果读取到了其他事务还没有提交的事务，结果读 取结果age=20，这就是脏读。
>
> read commit 读已提交，两次读取结果不⼀致，叫做不可重复读。 ●
>
> 不可重复读解决了脏读的问题，他只会读取已经提交的事务。
>
> ⽤户开启事务读取id=1⽤户，查询到age=10，再次读取发现结果=20，在同⼀个事务⾥同⼀个查询 读取到不同的结果叫做不可重复读。
>
> repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都⼀样，但是有可能产 ●
>
> ⽣幻读。
>
> serializable 串⾏，⼀般是不会使⽤的，他会给每⼀⾏读取的数据加锁，会导致⼤量超时和锁竞争 ●
>
> 的问题。
>
> 脏读(Drity Read)：某个事务已更新⼀份数据，另⼀个事务在此时读取了同⼀份数据，由于某些原因， 前⼀个RollBack了操作，则后⼀个事务所读取的数据就会是不正确的。
>
> 不可重复读(Non-repeatable read):在⼀个事务的两次查询之中数据不⼀致，这可能是两次查询过程中 间插⼊了⼀个事务更新的原有的数据。
>
> 幻读(Phantom Read):在⼀个事务的两次查询中数据笔数不⼀致，例如有⼀个事务查询了⼏列(Row)数 据，⽽另⼀个事务却在此时插⼊了新的⼏列数据，先前的事务在接下来的查询中，就会发现有⼏列数据 是它先前所没有的。
>
> ACID靠什么保证的？

62

> A原⼦性由undo log⽇志保证，它记录了需要回滚的⽇志信息，事务回滚时撤销已经执⾏成功的sql C⼀致性由其他三⼤特性保证、程序代码要保证业务上的⼀致性
>
> I隔离性由MVCC来保证
>
> D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可 以从redo log恢复

Plain Text 复制代码

> 1
>
> InnoDB redo log 写盘，InnoDB 事务进⼊ prepare 状态。
>
> 2
>
> 如果前⾯ prepare 成功，binlog 写盘，再继续将事务⽇志持久化到 binlog，如果持久化成功，那 么 InnoDB 事务则进⼊ commit 状态(在 redo log ⾥⾯写⼀个 commit 记录)
>
> redolog的刷盘会在系统空闲时进⾏
>
> 什么是MVCC
>
> 多版本并发控制：读取数据时通过⼀种类似快照的⽅式将数据保存下来，这样读锁就和写锁不冲突了， 不同的事务session会看到⾃⼰特定版本的数据，版本链
>
> MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下⼯作。其他两个隔离级别够 和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据⾏, ⽽不是符合当前事务版本的数据 ⾏。⽽ SERIALIZABLE 则会对所有读取的⾏都加锁。
>
> 聚簇索引记录中有两个必要的隐藏列：
>
> trx_id：⽤来存储每次对某条聚簇索引记录进⾏修改的时候的事务id。
>
> roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把⽼版本写⼊undo⽇志中。这个 roll_pointer就是存了⼀个指针，它指向这条聚簇索引记录的上⼀个版本的位置，通过它来获得上⼀个版 本的记录信息。(注意插⼊操作的undo⽇志没有这个属性，因为它没有⽼版本)
>
> 已提交读和可重复读的区别就在于它们⽣成ReadView的策略不同。

63

> 开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序⽣成⼀个数组 访问数据，获取数据中的事务id（获取的是事务id最⼤的记录），对⽐readview： 如果在readview的左边（⽐readview都⼩），可以访问（在左边意味着该事务已经提交）
>
> 如果在readview的右边（⽐readview都⼤）或者就在readview中，不可以访问，获取roll_pointer，取 上⼀版本重新对⽐（在右边意味着，该事务在readview⽣成之后出现，在readview中意味着该事务还未 提交）
>
> 已提交读隔离级别下的事务在每次查询的开始都会⽣成⼀个独⽴的ReadView,⽽可重复读隔离级别则在 第⼀次读的时候⽣成⼀个ReadView，之后的读都复⽤之前的ReadView。
>
> 这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView⽣成策略的不 同实现不同的隔离级别。
>
> 分表后⾮sharding_key的查询怎么处理，分表后的排序？
>
> 1\. 可以做⼀个mapping表，⽐如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能 扫全表吧？所以我们可以做⼀个映射关系表，保存商家和⽤户的关系，查询的时候先通过商家查询 到⽤户列表，再通过user_id去查询。
>
> 2\. 宽表，对数据实时性要求不是很⾼的场景，⽐如查询订单列表，可以把订单表同步到离线（实时） 数仓，再基于数仓去做成⼀张宽表，再基于其他如es提供查询服务。
>
> 3\. 数据量不是很⼤的话，⽐如后台的⼀些查询之类的，也可以通过多线程扫表，然后再聚合结果的⽅ 式来做。或者异步的形式也是可以的。
>
> union
>
> 排序字段是唯⼀索引：
>
> ⾸先第⼀⻚的查询：将各表的结果集进⾏合并，然后再次排序
>
> ●
>
> 第⼆⻚及以后的查询，需要传⼊上⼀⻚排序字段的最后⼀个值，及排序⽅式。 ●
>
> 根据排序⽅式，及这个值进⾏查询。如排序字段date，上⼀⻚最后值为3，排序⽅式降序。查询的 ●

时候sql为select \... from table where date \< 3 order by date desc limit 0,10。这样再将⼏个表

64

> 的结果合并排序即可。
>
> Mysql主从同步原理
>
> mysql主从同步的过程：
>
> Mysql的主从复制中主要有三个线程： master（binlog dump thread）、slave（I/O thread 、SQL thread） ，Master⼀条线程和Slave中的两条线程。
>
> 主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服 ●
>
> 务器启动的那⼀刻起，保存所有修改数据库结构或内容的⼀个⽂件。
>
> 主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。 ●
>
> 从节点 I/O线程接收 binlog 内容，并将其写⼊到 relay log ⽂件中。
>
> ●
>
> 从节点的SQL 线程读取 relay log ⽂件内容对数据更新进⾏重放，最终保证主从数据库的⼀致性。 ●
>
> 注：主从节点使⽤ binglog ⽂件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的 偏移量，如果从节点发⽣宕机重启，则会⾃动从 position 的位置发起同步。
>
> 由于mysql默认的复制⽅式是异步的，主库把⽇志发送给从库后不关⼼从库是否已经处理，这样会产⽣ ⼀个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，⽇志就丢失了。由此产⽣两个 概念。
>
> 全同步复制
>
> 主库写⼊binlog后强制同步⽇志到从库，所有的从库都执⾏完成后才返回给客户端，但是很显然这个⽅ 式的话性能会受到严重影响。
>
> 半同步复制
>
> 和全同步不同的是，半同步复制的逻辑是这样，从库写⼊⽇志成功后返回ACK确认给主库，主库收到⾄ 少⼀个从库的确认就认为写操作完成。
>
> 简述MyISAM和InnoDB的区别

65

> MyISAM：
>
> 不⽀持事务，但是每次查询都是原⼦的；
>
> ●
>
> ⽀持表级锁，即每次操作是对整个表加锁；
>
> ●
>
> 存储表的总⾏数；
>
> ●
>
> ⼀个MYISAM表有三个⽂件：索引⽂件、表结构⽂件、数据⽂件；
>
> ●
>
> 采⽤⾮聚集索引，索引⽂件的数据域存储指向数据⽂件的指针。辅索引与主索引基本⼀致，但是辅 ●
>
> 索引不⽤保证唯⼀性。
>
> InnoDb：
>
> ⽀持ACID的事务，⽀持事务的四种隔离级别；
>
> ●
>
> ⽀持⾏级锁及外键约束：因此可以⽀持写并发；
>
> ●
>
> 不存储总⾏数；
>
> ●
>
> ⼀个InnoDb引擎存储在⼀个⽂件空间（共享表空间，表⼤⼩不受操作系统控制，⼀个表可能分布在 ●
>
> 多个⽂件⾥），也有可能为多个（设置为独⽴表空，表⼤⼩受操作系统⽂件⼤⼩限制，⼀般为 2G），受操作系统⽂件⼤⼩的限制；
>
> 主键索引采⽤聚集索引（索引的数据域存储数据⽂件本身），辅索引的数据域存储主键的值；因此 ●
>
> 从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使⽤⾃增主键，防⽌插⼊ 数据时，为维持B+树结构，⽂件的⼤调整。
>
> 简述Mysql中索引类型及对数据库的性能的影响
>
> 普通索引：允许被索引的数据列包含重复的值。
>
> 唯⼀索引：可以保证数据记录的唯⼀性。
>
> 主键：是⼀种特殊的唯⼀索引，在⼀张表中只能定义⼀个主键索引，主键⽤于唯⼀标识⼀条记录，使⽤ 关键字 PRIMARY KEY 来创建。
>
> 联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。
>
> 全⽂索引：通过建⽴ 倒排索引 ,可以极⼤的提升检索效率,解决判断字段是否包含的问题，是⽬前搜索引 擎使⽤的⼀种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全⽂索 引
>
> 索引可以极⼤的提⾼数据的查询速度。

66

> 通过使⽤索引，可以在查询的过程中，使⽤优化隐藏器，提⾼系统的性能。
>
> 但是会降低插⼊、删除、更新表的速度，因为在执⾏这些写操作时，还要操作索引⽂件
>
> 索引需要占物理空间，除了数据表占数据空间之外，每⼀个索引还要占⼀定的物理空间，如果要建⽴聚 簇索引，那么需要的空间就会更⼤，如果⾮聚集索引很多，⼀旦聚集索引改变，那么所有⾮聚集索引都 会跟着变。
>
> Explain语句结果中各个字段分表表示什么

+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > 列名                            | > 描述                                                                                                                  |
+===================================+=========================================================================================================================+
| > id                              | > 查询语句中每出现⼀个SELECT关键字，MySQL 就会为它分配⼀个唯⼀的id值，某些⼦查询会被 优化为join查询，那么出现的id会⼀样 |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > select_type                     | > SELECT关键字对应的那个查询的类型                                                                                      |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > table                           | > 表名                                                                                                                  |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > partitions                      | > 匹配的分区信息                                                                                                        |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > type                            | > 针对单表的查询⽅式（全表扫描、索引）                                                                                  |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > possible_keys                   | > 可能⽤到的索引                                                                                                        |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > key                             | > 实际上使⽤的索引                                                                                                      |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > key_len                         | > 实际使⽤到的索引⻓度                                                                                                  |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > ref                             | > 当使⽤索引列等值查询时，与索引列进⾏等值匹 配的对象信息                                                               |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > rows                            | > 预估的需要读取的记录条数                                                                                              |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > filtered                        | > 某个表经过搜索条件过滤后剩余记录条数的百分 ⽐                                                                         |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| > Extra                           | > ⼀些额外的信息，⽐如排序等                                                                                            |
+-----------------------------------+-------------------------------------------------------------------------------------------------------------------------+

67

> 索引覆盖是什么
>
> 索引覆盖就是⼀个SQL在执⾏时，可以利⽤索引来快速查找，并且此SQL所要查询的字段在当前索引对 应的字段中都包含了，那么就表示此SQL⾛完索引后不⽤回表了，所需要的字段都在当前索引的叶⼦节 点上存在，可以直接作为结果返回了
>
> 最左前缀原则是什么
>
> 当⼀个SQL想要利⽤索引是，就⼀定要提供该索引所对应的字段中最左边的字段，也就是排在最前⾯的 字段，⽐如针对a,b,c三个字段建⽴了⼀个联合索引，那么在写⼀个sql时就⼀定要提供a字段的条件，这 样才能⽤到联合索引，这是由于在建⽴a,b,c三个字段的联合索引时，底层的B+树是按照a,b,c三个字段 从左往右去⽐较⼤⼩进⾏排序的，所以如果想要利⽤B+树进⾏快速查找也得符合这个规则
>
> Innodb是如何实现事务的
>
> Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例： 1. Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在Buffer Pool 中
>
> 2\. 执⾏update语句，修改Buffer Pool中的数据，也就是内存中的数据
>
> 3\. 针对update语句⽣成⼀个RedoLog对象，并存⼊LogBuffer中
>
> 4\. 针对update语句⽣成undolog⽇志，⽤于事务回滚
>
> 5\. 如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将Buffer Pool中所修改的 数据⻚持久化到磁盘中
>
> 6\. 如果事务回滚，则利⽤undolog⽇志进⾏回滚
>
> B树和B+树的区别，为什么Mysql使⽤B+树
>
> B树的特点：
>
> 1\. 节点排序
>
> 2\. ⼀个节点了可以存多个元素，多个元素也排序了
>
> B+树的特点：
>
> 1\. 拥有B树的特点
>
> 2\. 叶⼦节点之间有指针

3\. ⾮叶⼦节点上的元素在叶⼦节点上都冗余了，也就是叶⼦节点中存储了所有的元素，并且排好顺序

68

> Mysql索引使⽤的是B+树，因为索引是⽤来加快查询的，⽽B+树通过对数据进⾏排序所以是可以提⾼查 询速度的，然后通过⼀个节点中可以存储多个元素，从⽽可以使得B+树的⾼度不会太⾼，在Mysql中⼀ 个Innodb⻚就是⼀个B+树节点，⼀个Innodb⻚默认16kb，所以⼀般情况下⼀颗两层的B+树可以存2000 万⾏左右的数据，然后通过利⽤B+树叶⼦节点存储了所有数据并且进⾏了排序，并且叶⼦节点之间有指 针，可以很好的⽀持全表扫描，范围查找等SQL语句。
>
> Mysql锁有哪些，如何理解
>
> 按锁粒度分类：
>
> 1\. ⾏锁：锁某⾏数据，锁粒度最⼩，并发度⾼
>
> 2\. 表锁：锁整张表，锁粒度最⼤，并发度低
>
> 3\. 间隙锁：锁的是⼀个区间
>
> 还可以分为：
>
> 1\. 共享锁：也就是读锁，⼀个事务给某⾏数据加了读锁，其他事务也可以读，但是不能写 2. 排它锁：也就是写锁，⼀个事务给某⾏数据加了写锁，其他事务不能读，也不能写
>
> 还可以分为：
>
> 1\. 乐观锁：并不会真正的去锁某⾏记录，⽽是通过⼀个版本号来实现的
>
> 2\. 悲观锁：上⾯所的⾏锁、表锁等都是悲观锁
>
> 在事务的隔离级别实现中，就需要利⽤锁来解决幻读
>
> Mysql慢查询该如何优化？
>
> 1\. 检查是否⾛了索引，如果没有则优化SQL利⽤索引
>
> 2\. 检查所利⽤的索引，是否是最优索引
>
> 3\. 检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据
>
> 4\. 检查表中数据是否过多，是否应该进⾏分库分表了
>
> 5\. 检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源
>
> Redis(14)

69

> 什么是RDB和AOF
>
> RDB：Redis DataBase，在指定的时间间隔内将内存中的数据集快照写⼊磁盘，实际操作过程是fork⼀ 个⼦进程，先将数据集写⼊临时⽂件，写⼊成功后，再替换之前的⽂件，⽤⼆进制压缩存储。
>
> 优点：
>
> 1\. 整个Redis数据库将只包含⼀个⽂件 dump.rdb，⽅便持久化。
>
> 2\. 容灾性好，⽅便备份。
>
> 3\. 性能最⼤化，fork ⼦进程来完成写操作，让主进程继续处理命令，所以是 IO 最⼤化。使⽤单独⼦ 进程来进⾏持久化，主进程不会进⾏任何 IO 操作，保证了 redis 的⾼性能
>
> 4\. 相对于数据集⼤时，⽐ AOF 的启动效率更⾼。
>
> 缺点：
>
> 1\. 数据安全性低。RDB 是间隔⼀段时间进⾏持久化，如果持久化之间 redis 发⽣故障，会发⽣数据丢 失。所以这种⽅式更适合数据要求不严谨的时候)
>
> 2\. 由于RDB是通过fork⼦进程来协助完成数据持久化⼯作的，因此，如果当数据集较⼤时，可能会导 致整个服务器停⽌服务⼏百毫秒，甚⾄是1秒钟。
>
> AOF：Append Only File，以⽇志的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记 录，以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录
>
> 优点：
>
> 1\. 数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也 是异步完成的，其效率也是⾮常⾼的，所差的是⼀旦系统出现宕机现象，那么这⼀秒钟之内修改的 数据将会丢失。⽽每修改同步，我们可以将其视为同步持久化，即每次发⽣的数据变化都会被⽴即 记录到磁盘中。。
>
> 2\. 通过 append 模式写⽂件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis check-aof ⼯具解决数据⼀致性问题。
>
> 3\. AOF 机制的 rewrite 模式。定期对AOF⽂件进⾏重写，以达到压缩的⽬的
>
> 缺点：
>
> 1\. AOF ⽂件⽐ RDB ⽂件⼤，且恢复速度慢。
>
> 2\. 数据集⼤的时候，⽐ rdb 启动效率低。
>
> 3\. 运⾏效率没有RDB⾼

70

> AOF⽂件⽐RDB更新频率⾼，优先使⽤AOF还原数据，AOF⽐RDB更安全也更⼤，RDB性能⽐AOF好， 如果两个都配了优先加载AOF。
>
> Redis的过期键的删除策略
>
> Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当 Redis中缓存的key过期了，Redis如何处理。
>
> 惰性过期：只有当访问⼀个key时，才会判断该key是否已过期，过期则清除。该策略可以最⼤化地 ●
>
> 节省CPU资源，却对内存⾮常不友好。极端情况可能出现⼤量的过期key没有再次被访问，从⽽不 会被清除，占⽤⼤量内存。
>
> 定期过期：每隔⼀定的时间，会扫描⼀定数量的数据库的expires字典中⼀定数量的key，并清除其 ●
>
> 中已过期的key。该策略是⼀个折中⽅案。通过调整定时扫描的时间间隔和每次扫描的限定耗时， 可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
>
> (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的 指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有 键。)
>
> Redis中同时使⽤了惰性过期和定期过期两种过期策略。
>
> Redis线程模型、单线程快的原因
>
> Redis基于Reactor模式开发了⽹络事件处理器，这个处理器叫做⽂件事件处理器 file event handler。 这个⽂件事件处理器，它是单线程的，所以 Redis 才叫做单线程的模型，它采⽤IO多路复⽤机制来同时 监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现⾼性能 的⽹络通信模型，⼜可以跟内部其他单线程的模块进⾏对接，保证了 Redis 内部的线程模型的简单性。
>
> ⽂件事件处理器的结构包含4个部分：多个Socket、IO多路复⽤程序、⽂件事件分派器以及事件处理器 （命令请求处理器、命令回复处理器、连接应答处理器等）。
>
> 多个 Socket 可能并发的产⽣不同的操作，每个操作对应不同的⽂件事件，但是IO多路复⽤程序会监听 多个 Socket，会将 Socket 放⼊⼀个队列中排队，每次从队列中取出⼀个 Socket 给事件分派器，事件 分派器把 Socket 给对应的事件处理器。

71

> 然后⼀个 Socket 的事件处理完之后，IO多路复⽤程序才会将队列中的下⼀个 Socket 给事件分派器。 ⽂件事件分派器会根据每个 Socket 当前产⽣的事件，来选择对应的事件处理器来处理。
>
> 单线程快的原因：
>
> 1）纯内存操作
>
> 2）核⼼是基于⾮阻塞的IO多路复⽤机制
>
> 3）单线程反⽽避免了多线程的频繁上下⽂切换带来的性能问题
>
> 简述Redis事务实现
>
> 1、事务开始
>
> MULTI命令的执⾏，标识着⼀个事务的开始。MULTI命令会将客户端状态的 flags 属性中打开 REDIS_MULTI 标识来完成的。
>
> 2、命令⼊队
>
> 当⼀个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执⾏不同的操作。如果客 户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的⼀个，⽴即执⾏这个命令，否则将命令放 ⼊⼀个事务队列⾥⾯，然后向客户端返回 QUEUED 回复
>
> 如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中⼀个，那么服务 ●
>
> 器⽴即执⾏这个命令。
>
> 如果客户端发送的是四个命令以外的其他命令，那么服务器并不⽴即执⾏这个命令。 ●
>
> ⾸先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属 性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。
>
> 如果正确，将这个命令放⼊⼀个事务队列⾥⾯，然后向客户端返回 QUEUED 回复
>
> 事务队列是按照FIFO的⽅式保存⼊队的命令 3、事务执⾏

72

> 客户端发送 EXEC 命令，服务器执⾏ EXEC 命令逻辑。
>
> 如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 ●
>
> REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执⾏。
>
> 否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然 ●
>
> 后执⾏事务队列中的所有命令，最后将返回结果全部返回给客户端；
>
> redis 不⽀持事务回滚机制，但是它会检查每⼀个事务中的命令是否错误。
>
> Redis 事务不⽀持检查那些程序员⾃⼰逻辑错误。例如对 String 类型的数据库键执⾏对 HashMap 类型 的操作！
>
> WATCH 命令是⼀个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）⾏为。可以监控⼀ ●
>
> 个或多个键，⼀旦其中有⼀个键被修改（或删除），之后的事务就不会执⾏，监控⼀直持续到 EXEC命令。
>
> MULTI命令⽤于开启⼀个事务，它总是返回OK。MULTI执⾏之后，客户端可以继续向服务器发送 ●
>
> 任意多条命令，这些命令不会⽴即被执⾏，⽽是被放到⼀个队列中，当EXEC命令被调⽤时，所有 队列中的命令才会被执⾏。
>
> EXEC：执⾏所有事务块内的命令。返回事务块内所有命令的返回值，按命令执⾏的先后顺序排 ●
>
> 列。当操作被打断时，返回空值 nil 。
>
> 通过调⽤DISCARD，客户端可以清空事务队列，并放弃执⾏事务， 并且客户端会从事务状态中退 ●
>
> 出。
>
> UNWATCH命令可以取消watch对所有key的监控。
>
> ●
>
> Redis 主从复制的核⼼原理
>
> 通过执⾏slaveof命令或设置slaveof选项，让⼀个服务器去复制另⼀个服务器的数据。主数据库可以进 ⾏读写操作，当写操作导致数据变化时会⾃动将数据同步给从数据库。⽽从数据库⼀般是只读的，并接 受主数据库同步过来的数据。⼀个主数据库可以拥有多个从数据库，⽽⼀个从数据库只能拥有⼀个主数 据库。
>
> 全量复制：
>
> 1\. 主节点通过bgsave命令fork⼦进程进⾏RDB持久化，该过程是⾮常消耗CPU、内存(⻚表复制)、硬 盘IO的
>
> 2\. 主节点通过⽹络将RDB⽂件发送给从节点，对主从节点的带宽都会带来很⼤的消耗

73

> 3\. 从节点清空⽼数据、载⼊新RDB⽂件的过程是阻塞的，⽆法响应客户端的命令；如果从节点执⾏ bgrewriteaof，也会带来额外的消耗
>
> 部分复制：
>
> 1\. 复制偏移量：执⾏复制的双⽅，主从节点，分别会维护⼀个复制偏移量offset 2. 复制积压缓冲区：主节点内部维护了⼀个固定⻓度的、先进先出(FIFO)队列 作为复制积压缓冲区， 当主从节点offset的差距过⼤超过缓冲区⻓度时，将⽆法执⾏部分复制，只能执⾏全量复制。 3. 服务器运⾏ID(runid)：每个Redis节点，都有其运⾏ID，运⾏ID由节点在启动时⾃动⽣成，主节点会 将⾃⼰的运⾏ID发送给从节点，从节点会将主节点的运⾏ID存起来。 从节点Redis断开重连的时 候，就是根据运⾏ID来判断同步的进度：
>
> 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续 ○
>
> 尝试使⽤部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)； 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不 ○
>
> 是当前的主节点，只能进⾏全量复制。
>
> Redis有哪些数据结构？分别有哪些典型的应⽤场景？ Redis的数据结构有：
>
> 1\. 字符串：可以⽤来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符 串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式 ID
>
> 2\. 哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象
>
> 3\. 列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似 微信公众号、微博等消息流数据
>
> 4\. 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作， 从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能
>
> 5\. 有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能
>
> Redis分布式锁底层是如何实现的？
>
> 1\. ⾸先利⽤setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁 2. 然后还要利⽤lua脚本来保证多个redis操作的原⼦性
>
> 3\. 同时还要考虑到锁过期，所以需要额外的⼀个看⻔狗定时任务来监听锁是否需要续约 4. 同时还要考虑到redis节点挂掉后的情况，所以需要采⽤红锁的⽅式来同时向N/2+1个节点申请锁， 都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到

74

> Redis主从复制的核⼼原理
>
> Redis的主从复制是提⾼Redis的可靠性的有效措施，主从复制的流程如下：
>
> 1\. 集群启动时，主从库间会先建⽴连接，为全量复制做准备
>
> 2\. 主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照 RDB
>
> 3\. 在主库将数据同步给从库的过程中，主库不会阻塞，仍然可以正常接收请求。否则，redis的服务就被中断 了。但是，这些请求中的写操作并没有记录到刚刚⽣成的RDB⽂件中。为了保证主从库的数据⼀致性，主 库会在内存中⽤专⻔的replication buffer，记录RDB⽂件⽣成收到的所有写操作。
>
> 4\. 最后，也就是第三个阶段，主库会把第⼆阶段执⾏过程中新收到的写命令，再发送给从库。具体的操作 是，当主库完成RDB⽂件发送后，就会把此时replocation buffer中修改操作发送给从库，从库再执⾏这些 操作。这样⼀来，主从库就实现同步了
>
> 5\. 后续主库和从库都可以处理客户端读操作，写操作只能交给主库处理，主库接收到写操作后，还会将写操 作发送给从库，实现增量同步
>
> Redis集群策略
>
> Redis提供了三种集群策略：
>
> 1\. 主从模式：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端 直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐ 较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量
>
> 2\. 哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕 机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵 节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤， 但是仍然不能很好的解决Redis的容量上限问题。
>
> 3\. Cluster模式：Cluster模式是⽤得⽐较多的模式，它⽀持多主多从，这种模式会按照key进⾏槽位的 分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数 据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举 ⼀个新的主节点。
>
> 对于这三种模式，如果Redis要存的数据量不⼤，可以选择哨兵模式，如果Redis要存的数据量⼤，并且 需要持续的扩容，那么选择Cluster模式。
>
> 缓存穿透、缓存击穿、缓存雪崩分别是什么
>
> 缓存中存放的⼤多都是热点数据，⽬的就是防⽌请求可以直接从缓存中获取到数据，⽽不⽤访问 Mysql。

75

> 1\. 缓存雪崩：如果缓存中某⼀时刻⼤批热点数据同时过期，那么就可能导致⼤量请求直接访问Mysql 了，解决办法就是在过期时间上增加⼀点随机值，另外如果搭建⼀个⾼可⽤的Redis集群也是防⽌ 缓存雪崩的有效⼿段
>
> 2\. 缓存击穿：和缓存雪崩类似，缓存雪崩是⼤批热点数据失效，⽽缓存击穿是指某⼀个热点key突然 失效，也导致了⼤量请求直接访问Mysql数据库，这就是缓存击穿，解决⽅案就是考虑这个热点key 不设过期时间
>
> 3\. 缓存穿透：假如某⼀时刻访问redis的⼤量key都在redis中不存在（⽐如⿊客故意伪造⼀些乱七⼋糟 的key），那么也会给数据造成压⼒，这就是缓存穿透，解决⽅案是使⽤布隆过滤器，它的作⽤就 是如果它认为⼀个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加⼀层布隆过滤器 来拦截不存在的key
>
> Redis和Mysql如何保证数据⼀致
>
> 1\. 先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不⼀致
>
> 2\. 先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种⽅案能解决1 ⽅案的问题，但是在⾼并发下性能较低，⽽且仍然会出现数据不⼀致的问题，⽐如线程1删除了 Redis缓存数据，正在更新Mysql，此时另外⼀个查询再查询，那么就会把Mysql中⽼数据⼜查到 Redis中
>
> 3\. 延时双删，步骤是：先删除Redis缓存数据，再更新Mysql，延迟⼏百毫秒再删除Redis缓存数据， 这样就算在更新Mysql时，有其他线程读了Mysql，把⽼数据读到了Redis中，那么也会被删除掉， 从⽽把数据保持⼀致
>
> Redis的持久化机制
>
> RDB：Redis DataBase 将某⼀个时刻的内存快照（Snapshot），以⼆进制的⽅式写⼊磁盘。 ⼿动触发：
>
> save命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所 ●
>
> 以在⽣产环境⼀定要慎⽤
>
> bgsave命令，fork出⼀个⼦进程执⾏持久化，主进程只在fork过程中有短暂的阻塞，⼦进程创建 ●
>
> 之后，主进程就可以响应客户端请求了

●

⾃动触发：

> save m n ：在 m 秒内，如果有 n 个键发⽣改变，则⾃动触发持久化，通过bgsave执⾏，如果设 ●
>
> 置多个、只要满⾜其⼀就会触发，配置⽂件有默认配置(可以注释掉)
>
> flushall：⽤于清空redis所有的数据库，flushdb清空当前redis所在库数据(默认是0号数据库)，会 ●
>
> 清空RDB⽂件，同时也会⽣成dump.rdb、内容为空
>
> 主从同步：全量同步时会⾃动触发bgsave命令，⽣成rdb发送给从节点 ●

76

> 优点：
>
> 1\. 整个Redis数据库将只包含⼀个⽂件 dump.rdb，⽅便持久化。
>
> 2\. 容灾性好，⽅便备份。
>
> 3\. 性能最⼤化，fork ⼦进程来完成写操作，让主进程继续处理命令，所以是 IO 最⼤化。使⽤单独⼦ 进程来进⾏持久化，主进程不会进⾏任何 IO 操作，保证了 redis 的⾼性能
>
> 4\. 相对于数据集⼤时，⽐ AOF的启动效率更⾼。
>
> 缺点：
>
> 1\. 数据安全性低。RDB 是间隔⼀段时间进⾏持久化，如果持久化之间 redis 发⽣故障，会发⽣数据丢 失。所以这种⽅式更适合数据要求不严谨的时候)
>
> 2\. 由于RDB是通过fork⼦进程来协助完成数据持久化⼯作的，因此，如果当数据集较⼤时，可能会导 致整个服务器停⽌服务⼏百毫秒，甚⾄是1秒钟。会占⽤cpu

AOF：Append Only File 以⽇志的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记录， 以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录，调操作系统命令进程刷盘 1. 所有的写命令会追加到 AOF 缓冲中。

> 2\. AOF 缓冲区根据对应的策略向硬盘进⾏同步操作。
>
> 3\. 随着 AOF ⽂件越来越⼤，需要定期对 AOF ⽂件进⾏重写，达到压缩的⽬的。 4. 当 Redis 重启时，可以加载 AOF ⽂件进⾏数据恢复。同步策略：
>
> 每秒同步：异步完成，效率⾮常⾼，⼀旦系统出现宕机现象，那么这⼀秒钟之内修改的数据将会丢 失 每修改同步：同步持久化，每次发⽣的数据变化都会被⽴即记录到磁盘中，最多丢⼀条 不同步：由操作 系统控制，可能丢失较多数据
>
> 优点：
>
> 1\. 数据安全
>
> 2\. 通过 append 模式写⽂件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis check-aof ⼯具解决数据⼀致性问题。
>
> 3\. AOF 机制的 rewrite 模式。定期对AOF⽂件进⾏重写，以达到压缩的⽬的
>
> 缺点：
>
> 1\. AOF ⽂件⽐ RDB ⽂件⼤，且恢复速度慢。
>
> 2\. 数据集⼤的时候，⽐ rdb 启动效率低。
>
> 3\. 运⾏效率没有RDB⾼
>
> 对⽐：
>
> AOF⽂件⽐RDB更新频率⾼，优先使⽤AOF还原数据。AOF⽐RDB更安全也更⼤ ●
>
> RDB性能⽐AOF好 ●

77

> 如果两个都配了优先加载AOF
>
> ●
>
> Redis单线程为什么这么快
>
> Redis基于Reactor模式开发了⽹络事件处理器、⽂件事件处理器 fileeventhandler。它是单线程的， 所 以 Redis才叫做单线程的模型，它采⽤IO多路复⽤机制来同时监听多个Socket，根据Socket上的事件类 型来选择对应的事件处理器来处理这个事件。可以实现⾼性能的⽹络通信模型，⼜可以跟内部其他单 线程的模块进⾏对接，保证了 Redis内部的线程模型的简单性。
>
> ⽂件事件处理器的结构包含4个部分：多个Socket、IO多路复⽤程序、⽂件事件分派器以及事件处理器 （命令请求处理器、命令回复处理器、连接应答处理器等）。
>
> 多个 Socket 可能并发的产⽣不同的事件，IO多路复⽤程序会监听多个 Socket，会将 Socket 放⼊⼀个 队列中排队，每次从队列中有序、同步取出⼀个 Socket 给事件分派器，事件分派器把 Socket 给对应 的事件处理器。
>
> 然后⼀个 Socket 的事件处理完之后，IO多路复⽤程序才会将队列中的下⼀个 Socket 给事件分派器。 ⽂件事件分派器会根据每个 Socket 当前产⽣的事件，来选择对应的事件处理器来处理。
>
> 1\. Redis启动初始化时，将连接应答处理器跟AE_READABLE事件关联。
>
> 2\. 若⼀个客户端发起连接，会产⽣⼀个AE_READABLE事件，然后由连接应答处理器负责和客户端建 ⽴ 连接，创建客户端对应的socket，同时将这个socket的AE_READABLE事件和命令请求处理 器关联，使 得客户端可以向主服务器发送命令请求。
>
> 3\. 当客户端向Redis发请求时（不管读还是写请求），客户端socket都会产⽣⼀个AE_READABLE事 件，触发命令请求处理器。处理器读取客户端的命令内容， 然后传给相关程序执⾏。 4. 当Redis服务器准备好给客户端的响应数据后，会将socket的AE_WRITABLE事件和命令回复处理 器关联，当客户端准备好读取响应数据时，会在socket产⽣⼀个AE_WRITABLE事件，由对应命令 回复处 理器处理，即将准备好的响应数据写⼊socket，供客户端读取。
>
> 5\. 命令回复处理器全部写完到 socket 后，就会删除该socket的AE_WRITABLE事件和命令回复处理 器的映射。
>
> 单线程快的原因：
>
> 1\. 纯内存操作
>
> 2\. 核⼼是基于⾮阻塞的IO多路复⽤机制
>
> 3\. 单线程反⽽避免了多线程的频繁上下⽂切换带来的性能问题

78

> 简述Redis事务实现
>
> 事务开始：MULTI命令的执⾏，标识着⼀个事务的开始。MULTI命令会将客户端状态的 flags属性 ●
>
> 中打开REDIS_MULTI标识来完成的。
>
> 命令⼊队：当⼀个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执⾏不同 ●
>
> 的操作。如果客 户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的⼀个，⽴即执⾏这个 命令，否则将命令放⼊⼀ 个事务队列⾥⾯，然后向客户端返回QUEUED回复，如果客户端发送的 命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中⼀个，那么服务器⽴即执⾏这个命 令。如果客户端发送的是四个命令以外的其他命令，那么服务器并不⽴即执⾏这个命令。⾸先检查 此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。如果正确，将这个命令放⼊⼀个事务队列⾥ ⾯，然后向客户端返回 QUEUED 回复事务队列是按照FIFO的⽅式保存⼊队的命令 事务执⾏：客户端发送 EXEC 命令，服务器执⾏ EXEC 命令逻辑。如果客户端状态的 flags 属性 ●
>
> 不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者REDIS_DIRTY_EXEC 标识，那么 就直接取消事务的执⾏。 否则客户端处于事务状态（flags有 REDIS_MULTI 标识），服务器会遍 历客户端的事务队列，然后执⾏事务队列中的所有命令，最后将返回结果全部返回给客户端； Redis不⽀持事务回滚机制，但是它会检查每⼀个事务中的命令是否错误。Redis事务不⽀持检查那 些程序员⾃⼰逻辑错误。例如对 String 类型的数据库键执⾏对 HashMap 类型的操作！
>
> 分布式与微服务(46)
>
> 什么是CAP理论
>
> CAP理论是分布式领域中⾮常重要的⼀个指导理论，C（Consistency）表示强⼀致性， A（Availability）表示可⽤性，P（Partition Tolerance）表示分区容错性，CAP理论指出在⽬前的硬件 条件下，⼀个分布式系统是必须要保证分区容错性的，⽽在这个前提下，分布式系统要么保证CP，要么 保证AP，⽆法同时保证CAP。
>
> 分区容错性表示，⼀个系统虽然是分布式的，但是对外看上去应该是⼀个整体，不能由于分布式系统内 部的某个结点挂点，或⽹络出现了故障，⽽导致系统对外出现异常。所以，对于分布式系统⽽⾔是⼀定 要保证分区容错性的。
>
> 强⼀致性表示，⼀个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提 供服务的，不然就会造成数据不⼀致，所以强⼀致性和可⽤性是不能同时满⾜的。
>
> 可⽤性表示，⼀个分布式系统对外要保证可⽤。

79

> 什么是BASE理论
>
> 由于不能同时满⾜CAP，所以出现了BASE理论：
>
> 1\. BA：Basically Available，表示基本可⽤，表示可以允许⼀定程度的不可⽤，⽐如由于系统故障， 请求时间变⻓，或者由于系统故障导致部分⾮核⼼功能不可⽤，都是允许的
>
> 2\. S：Soft state：表示分布式系统可以处于⼀种中间状态，⽐如数据正在同步 3. E：Eventually consistent，表示最终⼀致性，不要求分布式系统数据实时达到⼀致，允许在经过⼀ 段时间后再达到⼀致，在达到⼀致过程中，系统也是可⽤的
>
> 什么是RPC
>
> RPC，表示远程过程调⽤，对于Java这种⾯试对象语⾔，也可以理解为远程⽅法调⽤，RPC调⽤和 HTTP调⽤是有区别的，RPC表示的是⼀种调⽤远程⽅法的⽅式，可以使⽤HTTP协议、或直接基于TCP 协议来实现RPC，在Java中，我们可以通过直接使⽤某个服务接⼝的代理对象来执⾏⽅法，⽽底层则通 过构造HTTP请求来调⽤远端的⽅法，所以，有⼀种说法是RPC协议是HTTP协议之上的⼀种协议，也是 可以理解的。
>
> 数据⼀致性模型有哪些
>
> 强⼀致性：当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对 ●
>
> ⽤户 最友好的，就是⽤户上⼀次写什么，下⼀次就保证能读到什么。根据 CAP理论，这种实现需 要牺牲可⽤性。
>
> 弱⼀致性：系统在数据写⼊成功之后，不承诺⽴即可以读到最新写⼊的值，也不会具体的承诺多久 ●
>
> 之后 可以读到。⽤户读到某⼀操作对系统数据的更新需要⼀段时间，我们称这段时间为"不⼀致性 窗⼝"。
>
> 最终⼀致性：最终⼀致性是弱⼀致性的特例，强调的是所有的数据副本，在经过⼀段时间的同步之 ●
>
> 后， 最终都能够达到⼀个⼀致的状态。因此，最终⼀致性的本质是需要系统保证最终数据能够达 到⼀致，⽽ 不需要实时保证系统数据的强⼀致性。到达最终⼀致性的时间 ，就是不⼀致窗⼝时 间，在没有故障发⽣的前提下，不⼀致窗⼝的时间主要受通信延迟，系统负载和复制副本的个数影 响。最终⼀致性模型根据其提供的不同保证可以划分为更多的模型，包括因果⼀致性和会话⼀致性 等。

80
